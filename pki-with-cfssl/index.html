<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>PKI with CFSSL | Linuxera</title><meta name=keywords content="pki,private ca,TLS,cfssl"><meta name=description content="PKI with CFSSL
In this post we will learn how to deploy our own Public Key Infrastructure (PKI) by using the CFSSL tooling. This may be useful if you want to run your own Certificate Authority (CA) in order to issue certificates for your systems and/or users.
Introduction to CFSSL
CFSSL is a tool set created by Cloudflare and released as Open Source software. Before you continue reading this post I&rsquo;d suggest reading this introductory post to PKI and CFSSL by Cloudflare."><meta name=author content="Mario"><link rel=canonical href=https://linuxera.org/pki-with-cfssl/><link crossorigin=anonymous href=/assets/css/stylesheet.1cc86568976026a3a15721e44d6a2e7ec59507db18eff55b4171d66c54304079.css integrity="sha256-HMhlaJdgJqOhVyHkTWoufsWVB9sY7/VbQXHWbFQwQHk=" rel="preload stylesheet" as=style><link rel=icon href=https://linuxera.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://linuxera.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://linuxera.org/favicon-32x32.png><link rel=apple-touch-icon href=https://linuxera.org/apple-touch-icon.png><link rel=mask-icon href=https://linuxera.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://linuxera.org/pki-with-cfssl/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><script defer data-domain=linuxera.org src=https://stats.linuxera.org/js/script.file-downloads.hash.outbound-links.js></script><script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><meta property="og:url" content="https://linuxera.org/pki-with-cfssl/"><meta property="og:site_name" content="Linuxera"><meta property="og:title" content="PKI with CFSSL"><meta property="og:description" content="PKI with CFSSL In this post we will learn how to deploy our own Public Key Infrastructure (PKI) by using the CFSSL tooling. This may be useful if you want to run your own Certificate Authority (CA) in order to issue certificates for your systems and/or users.
Introduction to CFSSL CFSSL is a tool set created by Cloudflare and released as Open Source software. Before you continue reading this post I‚Äôd suggest reading this introductory post to PKI and CFSSL by Cloudflare."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-09T00:00:00+00:00"><meta property="article:tag" content="Pki"><meta property="article:tag" content="Private Ca"><meta property="article:tag" content="TLS"><meta property="article:tag" content="Cfssl"><meta name=twitter:card content="summary"><meta name=twitter:title content="PKI with CFSSL"><meta name=twitter:description content="PKI with CFSSL
In this post we will learn how to deploy our own Public Key Infrastructure (PKI) by using the CFSSL tooling. This may be useful if you want to run your own Certificate Authority (CA) in order to issue certificates for your systems and/or users.
Introduction to CFSSL
CFSSL is a tool set created by Cloudflare and released as Open Source software. Before you continue reading this post I&rsquo;d suggest reading this introductory post to PKI and CFSSL by Cloudflare."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://linuxera.org/posts/"},{"@type":"ListItem","position":2,"name":"PKI with CFSSL","item":"https://linuxera.org/pki-with-cfssl/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"PKI with CFSSL","name":"PKI with CFSSL","description":"PKI with CFSSL In this post we will learn how to deploy our own Public Key Infrastructure (PKI) by using the CFSSL tooling. This may be useful if you want to run your own Certificate Authority (CA) in order to issue certificates for your systems and/or users.\nIntroduction to CFSSL CFSSL is a tool set created by Cloudflare and released as Open Source software. Before you continue reading this post I\u0026rsquo;d suggest reading this introductory post to PKI and CFSSL by Cloudflare.\n","keywords":["pki","private ca","TLS","cfssl"],"articleBody":"PKI with CFSSL In this post we will learn how to deploy our own Public Key Infrastructure (PKI) by using the CFSSL tooling. This may be useful if you want to run your own Certificate Authority (CA) in order to issue certificates for your systems and/or users.\nIntroduction to CFSSL CFSSL is a tool set created by Cloudflare and released as Open Source software. Before you continue reading this post I‚Äôd suggest reading this introductory post to PKI and CFSSL by Cloudflare.\nThis post assumes you already have basic knowledge on PKI and in how the CFSSL tooling works, if you don‚Äôt have it, go read the post linked above.\nInstalling the CFSSL tooling In order to install the CFSSL tooling you can go to the GitHub Releases and download the binaries from there.\nWarning\nBelow commands will only work for Linux x86_64 machines.\nsudo curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssl_1.6.4_linux_amd64 -o /usr/local/bin/cfssl sudo curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssljson_1.6.4_linux_amd64 -o /usr/local/bin/cfssljson sudo curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/multirootca_1.6.4_linux_amd64 -o /usr/local/bin/multirootca sudo chmod +x /usr/local/bin/{cfssl,cfssljson,multirootca} PKI Organization For this example, the following organization will be used.\nCreating the Root CA Let‚Äôs create a folder to store the PKI files:\nmkdir -p ~/cafiles/{root,intermediate,config,certificates} Before issuing the Root CA, we need to define its config:\nNote\nThe expiration is 10 years. You want to have a long expiration time for your Root CA to avoid having to re-roll the PKI too often.\ncat \u003c\u003c \"EOF\" \u003e ~/cafiles/root/root-csr.json { \"CN\": \"Linuxera Root Certificate Authority\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 }, \"names\": [ { \"C\": \"ES\", \"L\": \"Valencia\", \"O\": \"Linuxera Internal\", \"OU\": \"CA Services\", \"ST\": \"Valencia\" } ], \"ca\": { \"expiry\": \"87600h\" } } EOF Issue the Root CA with cfssl:\ncfssl gencert -initca ~/cafiles/root/root-csr.json | cfssljson -bare ~/cafiles/root/root-ca At this point, we have our Root CA ready.\nCreating the Intermediate CA Issuing certificates directly with the Root CA is not advised. You should be issuing intermediary CAs with the Root CA instead. This allows for better organization of your PKI, and in case of a security incident you won‚Äôt have to re-roll the whole PKI, instead you will only re-roll the affected Intermediate CA.\nFor this test, we will be issuing only an Intermediate CA. In real scenarios, is pretty common having multiple intermediates, and sometimes these intermediate CAs will be used to issue other intermediate CAs.\nDefine the Intermediate CA config:\nNote\nThe expiration is 8 years. For Intermediate CAs you also want to have quite a long expiration time.\ncat \u003c\u003c \"EOF\" \u003e ~/cafiles/intermediate/intermediate-csr.json { \"CN\": \"Linuxera Intermediate CA\", \"key\": { \"algo\": \"ecdsa\", \"size\": 256 }, \"names\": [ { \"C\": \"ES\", \"L\": \"Valencia\", \"O\": \"Linuxera Internal\", \"OU\": \"Linuxera Internal Intermediate CA\", \"ST\": \"Valencia\" } ] } EOF Generate the key for the Intermediate CA:\ncfssl genkey ~/cafiles/intermediate/intermediate-csr.json | cfssljson -bare ~/cafiles/intermediate/intermediate-ca Define a CFSSL signing profile for the Intermediate CAs. This is done via a config file.\ncert sign and crl sign Expiration set to 8 years. CA constraints define that the certificates issued will be used by CAs is_ca: true and max_path_len: 1 limits this intermediate CA to only be able to issue sub-intermediate CAs that cannot issue additional CAs. (This could be allowed with max_path_len: 0 and max_path_len_zero: true). cat \u003c\u003c \"EOF\" \u003e ~/cafiles/config/config.json { \"signing\": { \"default\": { \"expiry\": \"8760h\" }, \"profiles\": { \"intermediate\": { \"usages\": [\"cert sign\", \"crl sign\"], \"expiry\": \"70080h\", \"ca_constraint\": { \"is_ca\": true, \"max_path_len\": 1 } } } } } EOF Sign the Intermediate CA with the Root CA:\ncfssl sign -ca ~/cafiles/root/root-ca.pem -ca-key ~/cafiles/root/root-ca-key.pem -config ~/cafiles/config/config.json -profile intermediate ~/cafiles/intermediate/intermediate-ca.csr | cfssljson -bare ~/cafiles/intermediate/intermediate-ca At this point, our Intermediate CA is ready to issue certificates, and we can take our Root CA offline. Usually, the private key gets stored in an HSM and after that it‚Äôs deleted from the file system.\nrm -f ~/cafiles/root/root-ca-key.pem Issuing certificates with the Intermediate CA Before issuing the certificate, we will add a new signing profile to our config. We will be defining a host signing profile that defines different usages as well as an expiration of 1 year for the certificates.\ncat \u003c\u003c \"EOF\" \u003e ~/cafiles/config/config.json { \"signing\": { \"default\": { \"expiry\": \"8760h\" }, \"profiles\": { \"intermediate\": { \"usages\": [\"cert sign\", \"crl sign\"], \"expiry\": \"70080h\", \"ca_constraint\": { \"is_ca\": true, \"max_path_len\": 1 } }, \"host\": { \"usages\": [\"signing\", \"digital signing\", \"key encipherment\", \"server auth\"], \"expiry\": \"8760h\" } } } } EOF With the profile ready, let‚Äôs create the certificate config:\ncat \u003c\u003c \"EOF\" \u003e ~/cafiles/certificates/my-host-csr.json { \"CN\": \"testhost.linuxera.org\", \"hosts\": [\"testhost.linuxera.org\", \"192.168.122.120\"], \"names\": [ { \"C\": \"ES\", \"L\": \"Valencia\", \"O\": \"Linuxera Internal\", \"OU\": \"Linuxera Internal Hosts\" } ] } EOF Finally, use the cfssl tooling to issue this certificate with the Intermediate CA using the host profile:\ncfssl gencert -ca ~/cafiles/intermediate/intermediate-ca.pem -ca-key ~/cafiles/intermediate/intermediate-ca-key.pem -config ~/cafiles/config/config.json -profile host ~/cafiles/certificates/my-host-csr.json | cfssljson -bare ~/cafiles/certificates/my-host At this point, we can verify the cert we just created:\nopenssl x509 -in ~/cafiles/certificates/my-host.pem -noout -subject -issuer -startdate -enddate Note\nWe can see the issuer is our Intermediate CA.\nsubject=C = ES, L = Valencia, O = Linuxera Internal, OU = Linuxera Internal Hosts, CN = testhost.linuxera.org issuer=C = ES, ST = Valencia, L = Valencia, O = Linuxera Internal, OU = Linuxera Internal Intermediate CA, CN = Linuxera Intermediate CA notBefore=Aug 9 10:09:00 2023 GMT notAfter=Aug 8 10:09:00 2024 GMT If we check the certificate file ~/cafiles/certificates/my-host.pem, we will see that it only contains the certificate for the host and not the full bundle (Intermediate CAs + Cert). We can generate a full chain cert with the command below:\nNote\nBundles are useful when you intend to use the certificate for an app like a web server, that way you will be sending the certificate + all the intermediate CAs certificates up to the Root CA so the client can verify its trust. Including the Root CA cert is not required, your client should already trust the Root CA, if it doesn‚Äôt trust it that won‚Äôt change even if you send it as part of the bundle.\ncfssl bundle -ca-bundle ~/cafiles/root/root-ca.pem -int-bundle ~/cafiles/intermediate/intermediate-ca.pem -cert ~/cafiles/certificates/my-host.pem | cfssljson -bare ~/cafiles/certificates/my-host-fullchain We should have the bundled cert available:\nWarning\nIn some Linux distributions, the previous cfssl bundle command may not generate the bundled cert. If that‚Äôs the case you can get the same result by running cat ~/cafiles/certificates/my-host.pem ~/cafiles/intermediate/intermediate-ca.pem \u003e ~/cafiles/certificates/my-host-fullchain.pem\ncat ~/cafiles/certificates/my-host-fullchain.pem -----BEGIN CERTIFICATE----- MII... -----END CERTIFICATE----- -----BEGIN CERTIFICATE----- MII... -----END CERTIFICATE----- Finally, we could verify the cert:\nopenssl verify -CAfile \u003c(cat ~/cafiles/root/root-ca.pem ~/cafiles/intermediate/intermediate-ca.pem) ~/cafiles/certificates/my-host.pem /home/mario/cafiles/certificates/my-host.pem: OK Exposing our PKI to remote systems with MultiRootCA So far, we have been using cfssl tooling to issue certificates while connected to a system where our PKI is stored. In real environments, you may need to issue certificates for different people/systems in a more convenient way.\nThe MultiRootCA program is an authenticated-signer-only server that is used as a remote server for cfssl instances. It is intended for:\nRunning cfssl as a service on servers to generate keys. Act as a remote signer to manage the CA keys for issuing certificates. Let‚Äôs start by issuing a certificate for the multirooca server:\ncat \u003c\u003c \"EOF\" \u003e ~/cafiles/certificates/multirootca-server-csr.json { \"CN\": \"multirootca-server.linuxera.org\", \"hosts\": [\"multirootca-server.linuxera.org\", \"192.168.122.153\"], \"names\": [ { \"C\": \"ES\", \"L\": \"Valencia\", \"O\": \"Linuxera Internal\", \"OU\": \"Linuxera Internal Hosts\" } ] } EOF cfssl gencert -ca ~/cafiles/intermediate/intermediate-ca.pem -ca-key ~/cafiles/intermediate/intermediate-ca-key.pem -config ~/cafiles/config/config.json -profile host ~/cafiles/certificates/multirootca-server-csr.json | cfssljson -bare ~/cafiles/certificates/multirootca-server We will secure the signing profiles in our config. We will be defining an auth_key that clients requesting a signed certificate must provide in order to get it signed.\nNote\nThe Auth Key is a 16 byte hexadecimal string. You can generate one by running openssl rand -hex 16\ncat \u003c\u003c \"EOF\" \u003e ~/cafiles/config/config.json { \"signing\": { \"default\": { \"expiry\": \"8760h\" }, \"profiles\": { \"intermediate\": { \"usages\": [\"cert sign\", \"crl sign\"], \"expiry\": \"70080h\", \"ca_constraint\": { \"is_ca\": true, \"max_path_len\": 1 } }, \"host\": { \"usages\": [\"signing\", \"digital signing\", \"key encipherment\", \"server auth\", \"client auth\"], \"expiry\": \"8760h\", \"auth_key\": \"default\" } } }, \"auth_keys\": { \"default\": { \"key\": \"b50ed348c4643d34706470f36a646fd4\", \"type\": \"standard\" } } } EOF We need to tell multirootca where to find the different certificates for our Intermediate CA:\ncat \u003c ~/cafiles/config/multiroot-profile.ini [linuxeraintermediate] private = file://${HOME}/cafiles/intermediate/intermediate-ca-key.pem certificate = ${HOME}/cafiles/intermediate/intermediate-ca.pem config = ${HOME}/cafiles/config/config.json EOF Finally, we can run the multirootca server:\nmultirootca -a 0.0.0.0:8000 -l default -roots ~/cafiles/config/multiroot-profile.ini -tls-cert ~/cafiles/certificates/multirootca-server.pem -tls-key ~/cafiles/certificates/multirootca-server-key.pem A more appropriate way of running the server would be using a systemd service:\ncat \u003c","wordCount":"1770","inLanguage":"en","datePublished":"2023-08-09T00:00:00Z","dateModified":"2023-08-09T00:00:00Z","author":{"@type":"Person","name":"Mario"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://linuxera.org/pki-with-cfssl/"},"publisher":{"@type":"Organization","name":"Linuxera","logo":{"@type":"ImageObject","url":"https://linuxera.org/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://linuxera.org/ accesskey=h title="Linuxera (Alt + H)">Linuxera</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://linuxera.org/ title="üè† Home"><span>üè† Home</span></a></li><li><a href=https://linuxera.org/archives/ title="üóÑÔ∏è Archive"><span>üóÑÔ∏è Archive</span></a></li><li><a href=https://linuxera.org/search/ title="üîé Search"><span>üîé Search</span></a></li><li><a href=https://linuxera.org/tags/ title="üè∑Ô∏è Tags"><span>üè∑Ô∏è Tags</span></a></li><li><a href=https://linuxera.org/presentations/ title="üé¥ Presentations"><span>üé¥ Presentations</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://linuxera.org/>Home</a>&nbsp;¬ª&nbsp;<a href=https://linuxera.org/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">PKI with CFSSL</h1><div class=post-meta>&lt;span title='2023-08-09 00:00:00 +0000 UTC'>Published on August 9, 2023&lt;/span>&amp;nbsp;¬∑&amp;nbsp;&lt;span title='2023-08-09 00:00:00 +0000 UTC'>Last updated on August 9, 2023&lt;/span>&amp;nbsp;¬∑&amp;nbsp;9 min&amp;nbsp;¬∑&amp;nbsp;Mario</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#pki-with-cfssl aria-label="PKI with CFSSL">PKI with CFSSL</a><ul><li><a href=#introduction-to-cfssl aria-label="Introduction to CFSSL">Introduction to CFSSL</a></li><li><a href=#installing-the-cfssl-tooling aria-label="Installing the CFSSL tooling">Installing the CFSSL tooling</a></li><li><a href=#pki-organization aria-label="PKI Organization">PKI Organization</a></li><li><a href=#creating-the-root-ca aria-label="Creating the Root CA">Creating the Root CA</a></li><li><a href=#creating-the-intermediate-ca aria-label="Creating the Intermediate CA">Creating the Intermediate CA</a></li><li><a href=#issuing-certificates-with-the-intermediate-ca aria-label="Issuing certificates with the Intermediate CA">Issuing certificates with the Intermediate CA</a></li><li><a href=#exposing-our-pki-to-remote-systems-with-multirootca aria-label="Exposing our PKI to remote systems with MultiRootCA">Exposing our PKI to remote systems with MultiRootCA</a></li><li><a href=#requesting-certificates-to-the-multirootca aria-label="Requesting certificates to the multirootca">Requesting certificates to the multirootca</a></li><li><a href=#closing-thoughts aria-label="Closing Thoughts">Closing Thoughts</a></li><li><a href=#useful-resources aria-label="Useful Resources">Useful Resources</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=pki-with-cfssl>PKI with CFSSL<a hidden class=anchor aria-hidden=true href=#pki-with-cfssl>#</a></h1><p>In this post we will learn how to deploy our own Public Key Infrastructure (PKI) by using the <a href=https://github.com/cloudflare/cfssl>CFSSL</a> tooling. This may be useful if you want to run your own Certificate Authority (CA) in order to issue certificates for your systems and/or users.</p><h2 id=introduction-to-cfssl>Introduction to CFSSL<a hidden class=anchor aria-hidden=true href=#introduction-to-cfssl>#</a></h2><p>CFSSL is a tool set created by <a href=https://www.cloudflare.com/>Cloudflare</a> and released as Open Source software. Before you continue reading this post I&rsquo;d suggest reading this <a href=https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/>introductory post to PKI and CFSSL by Cloudflare</a>.</p><p>This post assumes you already have basic knowledge on PKI and in how the CFSSL tooling works, if you don&rsquo;t have it, go read the post linked above.</p><h2 id=installing-the-cfssl-tooling>Installing the CFSSL tooling<a hidden class=anchor aria-hidden=true href=#installing-the-cfssl-tooling>#</a></h2><p>In order to install the CFSSL tooling you can go to the <a href=https://github.com/cloudflare/cfssl/releases>GitHub Releases</a> and download the binaries from there.</p><div class="admonition warning"><p class=admonition-title>Warning</p><p class=admonition>Below commands will only work for Linux x86_64 machines.</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssl_1.6.4_linux_amd64 -o /usr/local/bin/cfssl
</span></span><span class=line><span class=cl>sudo curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssljson_1.6.4_linux_amd64 -o /usr/local/bin/cfssljson
</span></span><span class=line><span class=cl>sudo curl -L https://github.com/cloudflare/cfssl/releases/download/v1.6.4/multirootca_1.6.4_linux_amd64 -o /usr/local/bin/multirootca
</span></span><span class=line><span class=cl>sudo chmod +x /usr/local/bin/<span class=o>{</span>cfssl,cfssljson,multirootca<span class=o>}</span>
</span></span></code></pre></div><h2 id=pki-organization>PKI Organization<a hidden class=anchor aria-hidden=true href=#pki-organization>#</a></h2><p>For this example, the following organization will be used.</p><p><img alt="CFSSL PKI Organization" loading=lazy src=/pki-with-cfssl/cfssl-pki-org.png></p><h2 id=creating-the-root-ca>Creating the Root CA<a hidden class=anchor aria-hidden=true href=#creating-the-root-ca>#</a></h2><ol><li><p>Let&rsquo;s create a folder to store the PKI files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>mkdir -p ~/cafiles/<span class=o>{</span>root,intermediate,config,certificates<span class=o>}</span>
</span></span></code></pre></div></li><li><p>Before issuing the Root CA, we need to define its config:</p><div class="admonition tip"><p class=admonition-title>Note</p><p class=admonition>The expiration is 10 years. You want to have a long expiration time for your Root CA to avoid having to re-roll the PKI too often.</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; ~/cafiles/root/root-csr.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;CN&#34;</span>: <span class=s2>&#34;Linuxera Root Certificate Authority&#34;</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;key&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;algo&#34;</span>: <span class=s2>&#34;ecdsa&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;size&#34;</span>: <span class=m>256</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;names&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;C&#34;</span>: <span class=s2>&#34;ES&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;L&#34;</span>: <span class=s2>&#34;Valencia&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;O&#34;</span>: <span class=s2>&#34;Linuxera Internal&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;OU&#34;</span>: <span class=s2>&#34;CA Services&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;ST&#34;</span>: <span class=s2>&#34;Valencia&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>]</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;ca&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;87600h&#34;</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div></li><li><p>Issue the Root CA with <code>cfssl</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cfssl gencert -initca ~/cafiles/root/root-csr.json <span class=p>|</span> cfssljson -bare ~/cafiles/root/root-ca
</span></span></code></pre></div></li><li><p>At this point, we have our Root CA ready.</p></li></ol><h2 id=creating-the-intermediate-ca>Creating the Intermediate CA<a hidden class=anchor aria-hidden=true href=#creating-the-intermediate-ca>#</a></h2><p>Issuing certificates directly with the Root CA is not advised. You should be issuing intermediary CAs with the Root CA instead. This allows for better organization of your PKI, and in case of a security incident you won&rsquo;t have to re-roll the whole PKI, instead you will only re-roll the affected Intermediate CA.</p><p>For this test, we will be issuing only an Intermediate CA. In real scenarios, is pretty common having multiple intermediates, and sometimes these intermediate CAs will be used to issue other intermediate CAs.</p><ol><li><p>Define the Intermediate CA config:</p><div class="admonition tip"><p class=admonition-title>Note</p><p class=admonition>The expiration is 8 years. For Intermediate CAs you also want to have quite a long expiration time.</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; ~/cafiles/intermediate/intermediate-csr.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;CN&#34;</span>: <span class=s2>&#34;Linuxera Intermediate CA&#34;</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;key&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;algo&#34;</span>: <span class=s2>&#34;ecdsa&#34;</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;size&#34;</span>: <span class=m>256</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;names&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;C&#34;</span>: <span class=s2>&#34;ES&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;L&#34;</span>: <span class=s2>&#34;Valencia&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;O&#34;</span>: <span class=s2>&#34;Linuxera Internal&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;OU&#34;</span>: <span class=s2>&#34;Linuxera Internal Intermediate CA&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;ST&#34;</span>: <span class=s2>&#34;Valencia&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div></li><li><p>Generate the key for the Intermediate CA:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cfssl genkey ~/cafiles/intermediate/intermediate-csr.json <span class=p>|</span> cfssljson -bare ~/cafiles/intermediate/intermediate-ca
</span></span></code></pre></div></li><li><p>Define a CFSSL <code>signing</code> profile for the Intermediate CAs. This is done via a config file.</p><ul><li><code>cert sign</code> and <code>crl sign</code></li><li>Expiration set to 8 years.</li><li>CA constraints define that the certificates issued will be used by CAs <code>is_ca: true</code> and <code>max_path_len: 1</code> limits this intermediate CA to only be able to issue sub-intermediate CAs that cannot issue additional CAs. (This could be allowed with <code>max_path_len: 0</code> and <code>max_path_len_zero: true</code>).</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; ~/cafiles/config/config.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;signing&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;default&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;8760h&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;profiles&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;intermediate&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;usages&#34;</span>: <span class=o>[</span><span class=s2>&#34;cert sign&#34;</span>, <span class=s2>&#34;crl sign&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;70080h&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ca_constraint&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;is_ca&#34;</span>: true,
</span></span><span class=line><span class=cl>          <span class=s2>&#34;max_path_len&#34;</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div></li><li><p>Sign the Intermediate CA with the Root CA:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cfssl sign -ca ~/cafiles/root/root-ca.pem -ca-key ~/cafiles/root/root-ca-key.pem -config ~/cafiles/config/config.json -profile intermediate ~/cafiles/intermediate/intermediate-ca.csr <span class=p>|</span> cfssljson -bare ~/cafiles/intermediate/intermediate-ca
</span></span></code></pre></div></li><li><p>At this point, our Intermediate CA is ready to issue certificates, and we can take our Root CA offline. Usually, the private key gets stored in an HSM and after that it&rsquo;s deleted from the file system.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>rm -f ~/cafiles/root/root-ca-key.pem
</span></span></code></pre></div></li></ol><h2 id=issuing-certificates-with-the-intermediate-ca>Issuing certificates with the Intermediate CA<a hidden class=anchor aria-hidden=true href=#issuing-certificates-with-the-intermediate-ca>#</a></h2><ol><li><p>Before issuing the certificate, we will add a new signing profile to our config. We will be defining a <code>host</code> signing profile that defines different usages as well as an expiration of 1 year for the certificates.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; ~/cafiles/config/config.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;signing&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;default&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;8760h&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;profiles&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;intermediate&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;usages&#34;</span>: <span class=o>[</span><span class=s2>&#34;cert sign&#34;</span>, <span class=s2>&#34;crl sign&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;70080h&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ca_constraint&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;is_ca&#34;</span>: true,
</span></span><span class=line><span class=cl>          <span class=s2>&#34;max_path_len&#34;</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;host&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;usages&#34;</span>: <span class=o>[</span><span class=s2>&#34;signing&#34;</span>, <span class=s2>&#34;digital signing&#34;</span>, <span class=s2>&#34;key encipherment&#34;</span>, <span class=s2>&#34;server auth&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;8760h&#34;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div></li><li><p>With the profile ready, let&rsquo;s create the certificate config:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; ~/cafiles/certificates/my-host-csr.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;CN&#34;</span>: <span class=s2>&#34;testhost.linuxera.org&#34;</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;hosts&#34;</span>: <span class=o>[</span><span class=s2>&#34;testhost.linuxera.org&#34;</span>, <span class=s2>&#34;192.168.122.120&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;names&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;C&#34;</span>: <span class=s2>&#34;ES&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;L&#34;</span>: <span class=s2>&#34;Valencia&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;O&#34;</span>: <span class=s2>&#34;Linuxera Internal&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;OU&#34;</span>: <span class=s2>&#34;Linuxera Internal Hosts&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div></li><li><p>Finally, use the <code>cfssl</code> tooling to issue this certificate with the Intermediate CA using the <code>host</code> profile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cfssl gencert -ca ~/cafiles/intermediate/intermediate-ca.pem -ca-key ~/cafiles/intermediate/intermediate-ca-key.pem -config ~/cafiles/config/config.json -profile host ~/cafiles/certificates/my-host-csr.json <span class=p>|</span> cfssljson -bare ~/cafiles/certificates/my-host
</span></span></code></pre></div></li><li><p>At this point, we can verify the cert we just created:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>openssl x509 -in ~/cafiles/certificates/my-host.pem -noout -subject -issuer -startdate -enddate
</span></span></code></pre></div><div class="admonition tip"><p class=admonition-title>Note</p><p class=admonition>We can see the issuer is our Intermediate CA.</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>subject=C = ES, L = Valencia, O = Linuxera Internal, OU = Linuxera Internal Hosts, CN = testhost.linuxera.org
</span></span></span><span class=line><span class=cl><span class=go>issuer=C = ES, ST = Valencia, L = Valencia, O = Linuxera Internal, OU = Linuxera Internal Intermediate CA, CN = Linuxera Intermediate CA
</span></span></span><span class=line><span class=cl><span class=go>notBefore=Aug 9 10:09:00 2023 GMT
</span></span></span><span class=line><span class=cl><span class=go>notAfter=Aug  8 10:09:00 2024 GMT
</span></span></span></code></pre></div></li><li><p>If we check the certificate file <code>~/cafiles/certificates/my-host.pem</code>, we will see that it only contains the certificate for the host and not the full bundle (Intermediate CAs + Cert). We can generate a full chain cert with the command below:</p><div class="admonition tip"><p class=admonition-title>Note</p><p class=admonition>Bundles are useful when you intend to use the certificate for an app like a web server, that way you will be sending the certificate + all the intermediate CAs certificates up to the Root CA so the client can verify its trust. Including the Root CA cert is not required, your client should already trust the Root CA, if it doesn&rsquo;t trust it that won&rsquo;t change even if you send it as part of the bundle.</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cfssl bundle -ca-bundle ~/cafiles/root/root-ca.pem -int-bundle ~/cafiles/intermediate/intermediate-ca.pem -cert ~/cafiles/certificates/my-host.pem <span class=p>|</span> cfssljson -bare ~/cafiles/certificates/my-host-fullchain
</span></span></code></pre></div></li><li><p>We should have the bundled cert available:</p><div class="admonition warning"><p class=admonition-title>Warning</p><p class=admonition>In some Linux distributions, the previous <code>cfssl bundle</code> command may not generate the bundled cert. If that&rsquo;s the case you can get the same result by running <code>cat ~/cafiles/certificates/my-host.pem ~/cafiles/intermediate/intermediate-ca.pem > ~/cafiles/certificates/my-host-fullchain.pem</code></p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat ~/cafiles/certificates/my-host-fullchain.pem
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>-----BEGIN CERTIFICATE-----
</span></span></span><span class=line><span class=cl><span class=go>MII...
</span></span></span><span class=line><span class=cl><span class=go>-----END CERTIFICATE-----
</span></span></span><span class=line><span class=cl><span class=go>-----BEGIN CERTIFICATE-----
</span></span></span><span class=line><span class=cl><span class=go>MII...
</span></span></span><span class=line><span class=cl><span class=go>-----END CERTIFICATE-----
</span></span></span></code></pre></div></li><li><p>Finally, we could verify the cert:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>openssl verify -CAfile &lt;<span class=o>(</span>cat ~/cafiles/root/root-ca.pem  ~/cafiles/intermediate/intermediate-ca.pem<span class=o>)</span> ~/cafiles/certificates/my-host.pem
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>/home/mario/cafiles/certificates/my-host.pem: OK
</span></span></span></code></pre></div></li></ol><h2 id=exposing-our-pki-to-remote-systems-with-multirootca>Exposing our PKI to remote systems with MultiRootCA<a hidden class=anchor aria-hidden=true href=#exposing-our-pki-to-remote-systems-with-multirootca>#</a></h2><p>So far, we have been using <code>cfssl</code> tooling to issue certificates while connected to a system where our PKI is stored. In real environments, you may need to issue certificates for different people/systems in a more convenient way.</p><p>The MultiRootCA program is an authenticated-signer-only server that is used as a remote server for <code>cfssl</code> instances. It is intended for:</p><ul><li>Running <code>cfssl</code> as a service on servers to generate keys.</li><li>Act as a remote signer to manage the CA keys for issuing certificates.</li></ul><ol><li><p>Let&rsquo;s start by issuing a certificate for the multirooca server:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; ~/cafiles/certificates/multirootca-server-csr.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;CN&#34;</span>: <span class=s2>&#34;multirootca-server.linuxera.org&#34;</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;hosts&#34;</span>: <span class=o>[</span><span class=s2>&#34;multirootca-server.linuxera.org&#34;</span>, <span class=s2>&#34;192.168.122.153&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;names&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;C&#34;</span>: <span class=s2>&#34;ES&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;L&#34;</span>: <span class=s2>&#34;Valencia&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;O&#34;</span>: <span class=s2>&#34;Linuxera Internal&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;OU&#34;</span>: <span class=s2>&#34;Linuxera Internal Hosts&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cfssl gencert -ca ~/cafiles/intermediate/intermediate-ca.pem -ca-key ~/cafiles/intermediate/intermediate-ca-key.pem -config ~/cafiles/config/config.json -profile host ~/cafiles/certificates/multirootca-server-csr.json  <span class=p>|</span> cfssljson -bare ~/cafiles/certificates/multirootca-server
</span></span></code></pre></div></li><li><p>We will secure the signing profiles in our config. We will be defining an <code>auth_key</code> that clients requesting a signed certificate must provide in order to get it signed.</p><div class="admonition tip"><p class=admonition-title>Note</p><p class=admonition>The Auth Key is a 16 byte hexadecimal string. You can generate one by running <code>openssl rand -hex 16</code></p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; ~/cafiles/config/config.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;signing&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;default&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;8760h&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;profiles&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;intermediate&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;usages&#34;</span>: <span class=o>[</span><span class=s2>&#34;cert sign&#34;</span>, <span class=s2>&#34;crl sign&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;70080h&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ca_constraint&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>          <span class=s2>&#34;is_ca&#34;</span>: true,
</span></span><span class=line><span class=cl>          <span class=s2>&#34;max_path_len&#34;</span>: <span class=m>1</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;host&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;usages&#34;</span>: <span class=o>[</span><span class=s2>&#34;signing&#34;</span>, <span class=s2>&#34;digital signing&#34;</span>, <span class=s2>&#34;key encipherment&#34;</span>, <span class=s2>&#34;server auth&#34;</span>, <span class=s2>&#34;client auth&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;expiry&#34;</span>: <span class=s2>&#34;8760h&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;auth_key&#34;</span>: <span class=s2>&#34;default&#34;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;auth_keys&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;default&#34;</span>: <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;key&#34;</span>: <span class=s2>&#34;b50ed348c4643d34706470f36a646fd4&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;type&#34;</span>: <span class=s2>&#34;standard&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div></li><li><p>We need to tell multirootca where to find the different certificates for our Intermediate CA:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat <span class=s>&lt;&lt;EOF &gt; ~/cafiles/config/multiroot-profile.ini
</span></span></span><span class=line><span class=cl><span class=s>[linuxeraintermediate]
</span></span></span><span class=line><span class=cl><span class=s>private = file://${HOME}/cafiles/intermediate/intermediate-ca-key.pem
</span></span></span><span class=line><span class=cl><span class=s>certificate = ${HOME}/cafiles/intermediate/intermediate-ca.pem
</span></span></span><span class=line><span class=cl><span class=s>config = ${HOME}/cafiles/config/config.json
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div></li><li><p>Finally, we can run the multirootca server:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>multirootca -a 0.0.0.0:8000 -l default -roots ~/cafiles/config/multiroot-profile.ini -tls-cert ~/cafiles/certificates/multirootca-server.pem -tls-key ~/cafiles/certificates/multirootca-server-key.pem
</span></span></code></pre></div></li><li><p>A more appropriate way of running the server would be using a systemd service:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat <span class=s>&lt;&lt;EOF | sudo tee /etc/systemd/system/multirootca.service
</span></span></span><span class=line><span class=cl><span class=s>[Unit]
</span></span></span><span class=line><span class=cl><span class=s>Description=CFSSL PKI Certificate Authority
</span></span></span><span class=line><span class=cl><span class=s>After=network.target
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>[Service]
</span></span></span><span class=line><span class=cl><span class=s>User=${USER}
</span></span></span><span class=line><span class=cl><span class=s>ExecStart=/usr/local/bin/multirootca -a 0.0.0.0:8000 -l linuxeraintermediate -roots ${HOME}/cafiles/config/multiroot-profile.ini -tls-cert ${HOME}/cafiles/certificates/multirootca-server.pem -tls-key ${HOME}/cafiles/certificates/multirootca-server-key.pem
</span></span></span><span class=line><span class=cl><span class=s>Restart=on-failure
</span></span></span><span class=line><span class=cl><span class=s>Type=simple
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>[Install]
</span></span></span><span class=line><span class=cl><span class=s>WantedBy=multi-user.target
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo systemctl daemon-reload
</span></span><span class=line><span class=cl>sudo systemctl <span class=nb>enable</span> multirootca --now
</span></span></code></pre></div></li></ol><h2 id=requesting-certificates-to-the-multirootca>Requesting certificates to the multirootca<a hidden class=anchor aria-hidden=true href=#requesting-certificates-to-the-multirootca>#</a></h2><p>Now that the Intermediate CA has been exposed with the multirootca program, we can go ahead and request it to sign some certificates. We can do this from a remote location, or from the same server where multirootca is running.</p><ol><li><p>Generate a certificate config:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat &lt;&lt; <span class=s2>&#34;EOF&#34;</span> &gt; my-cert-request-csr.json
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=s2>&#34;CN&#34;</span>: <span class=s2>&#34;myserver.linuxera.org&#34;</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;hosts&#34;</span>: <span class=o>[</span><span class=s2>&#34;myserver.linuxera.org&#34;</span>, <span class=s2>&#34;192.168.122.222&#34;</span><span class=o>]</span>,
</span></span><span class=line><span class=cl>  <span class=s2>&#34;names&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=s2>&#34;C&#34;</span>: <span class=s2>&#34;ES&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;L&#34;</span>: <span class=s2>&#34;Valencia&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;O&#34;</span>: <span class=s2>&#34;Linuxera Internal&#34;</span>,
</span></span><span class=line><span class=cl>      <span class=s2>&#34;OU&#34;</span>: <span class=s2>&#34;Linuxera Internal Hosts&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl>EOF
</span></span></code></pre></div></li><li><p>Generate a request profile. This is required for <code>cfssl</code> to know how to request the certificate to the multirootca:</p><div class="admonition warning"><p class=admonition-title>Warning</p><p class=admonition>We need to define the Auth key, otherwise multirootca will not sign our certificate. And the location of the multirootca server, we can use IP:Port or DNS:Port.</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat <span class=s>&lt;&lt;EOF &gt; request-profile.json
</span></span></span><span class=line><span class=cl><span class=s>{
</span></span></span><span class=line><span class=cl><span class=s>  &#34;signing&#34;: {
</span></span></span><span class=line><span class=cl><span class=s>    &#34;default&#34;: {
</span></span></span><span class=line><span class=cl><span class=s>      &#34;auth_remote&#34;: {
</span></span></span><span class=line><span class=cl><span class=s>        &#34;remote&#34;: &#34;ca_server&#34;,
</span></span></span><span class=line><span class=cl><span class=s>        &#34;auth_key&#34;: &#34;default&#34;
</span></span></span><span class=line><span class=cl><span class=s>      }
</span></span></span><span class=line><span class=cl><span class=s>    }
</span></span></span><span class=line><span class=cl><span class=s>  },
</span></span></span><span class=line><span class=cl><span class=s>  &#34;auth_keys&#34;: {
</span></span></span><span class=line><span class=cl><span class=s>    &#34;default&#34;: {
</span></span></span><span class=line><span class=cl><span class=s>      &#34;key&#34;: &#34;b50ed348c4643d34706470f36a646fd4&#34;,
</span></span></span><span class=line><span class=cl><span class=s>      &#34;type&#34;: &#34;standard&#34;
</span></span></span><span class=line><span class=cl><span class=s>    }
</span></span></span><span class=line><span class=cl><span class=s>  },
</span></span></span><span class=line><span class=cl><span class=s>  &#34;remotes&#34;: {
</span></span></span><span class=line><span class=cl><span class=s>    &#34;ca_server&#34;: &#34;https://multirootca-server.linuxera.org:8000&#34;
</span></span></span><span class=line><span class=cl><span class=s>  }
</span></span></span><span class=line><span class=cl><span class=s>}
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div></li><li><p>Finally, we send the request by specifying the <code>host</code> profile, which is the one we will be using for signing host certificates:</p><div class="admonition warning"><p class=admonition-title>Warning</p><p class=admonition>We need to specify the Intermediate CA certificate via the <code>-tls-remote-ca</code> flag.</p></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cfssl gencert -config ./request-profile.json -tls-remote-ca ./intermediate-ca.pem -profile host ./my-cert-request-csr.json <span class=p>|</span> cfssljson -bare my-cert
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>2023/08/09 11:43:15 [INFO] generate received request
</span></span></span><span class=line><span class=cl><span class=go>2023/08/09 11:43:15 [INFO] received CSR
</span></span></span><span class=line><span class=cl><span class=go>2023/08/09 11:43:15 [INFO] generating key: ecdsa-256
</span></span></span><span class=line><span class=cl><span class=go>2023/08/09 11:43:15 [INFO] encoded CSR
</span></span></span><span class=line><span class=cl><span class=go>2023/08/09 11:43:15 [INFO] Using trusted CA from tls-remote-ca: ./intermediate-ca.pem
</span></span></span></code></pre></div></li><li><p>We should have a valid certificate now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>openssl x509 -in ./my-cert.pem -noout -subject -issuer -startdate -enddate
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=line><span class=cl><span class=go>subject=C = ES, L = Valencia, O = Linuxera Internal, OU = Linuxera Internal Hosts, CN = myserver.linuxera.org
</span></span></span><span class=line><span class=cl><span class=go>issuer=C = ES, ST = Valencia, L = Valencia, O = Linuxera Internal, OU = Linuxera Internal Intermediate CA, CN = Linuxera Intermediate CA
</span></span></span><span class=line><span class=cl><span class=go>notBefore=Aug 9 11:38:00 2023 GMT
</span></span></span><span class=line><span class=cl><span class=go>notAfter=Aug  8 11:38:00 2024 GMT
</span></span></span></code></pre></div></li></ol><h2 id=closing-thoughts>Closing Thoughts<a hidden class=anchor aria-hidden=true href=#closing-thoughts>#</a></h2><p>We have seen how to run our own PKI with the CFSSL tooling, in the <a href=https://linuxera.org/integrating-cert-manager-with-cfssl-multirootca>next post</a> we will see how to leverage this PKI from Kubernetes by using <a href=https://cert-manager.io/>cert-manager</a>.</p><h2 id=useful-resources>Useful Resources<a hidden class=anchor aria-hidden=true href=#useful-resources>#</a></h2><ul><li><a href=https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/>https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/</a></li><li><a href=https://www.ekervhen.xyz/posts/private-ca-with-cfssl/>https://www.ekervhen.xyz/posts/private-ca-with-cfssl/</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://linuxera.org/tags/pki/>Pki</a></li><li><a href=https://linuxera.org/tags/private-ca/>Private Ca</a></li><li><a href=https://linuxera.org/tags/tls/>TLS</a></li><li><a href=https://linuxera.org/tags/cfssl/>Cfssl</a></li></ul><nav class=paginav><a class=prev href=https://linuxera.org/integrating-cert-manager-with-cfssl-multirootca/><span class=title>¬´ Prev</span><br><span>Integrating cert-manager with CFSSL Multirootca</span>
</a><a class=next href=https://linuxera.org/gateway-api-kubernetes/><span class=title>Next ¬ª</span><br><span>Gateway API for Kubernetes</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share PKI with CFSSL on x" href="https://x.com/intent/tweet/?text=PKI%20with%20CFSSL&amp;url=https%3a%2f%2flinuxera.org%2fpki-with-cfssl%2f&amp;hashtags=pki%2cprivateca%2cTLS%2ccfssl"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share PKI with CFSSL on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2flinuxera.org%2fpki-with-cfssl%2f&amp;title=PKI%20with%20CFSSL&amp;summary=PKI%20with%20CFSSL&amp;source=https%3a%2f%2flinuxera.org%2fpki-with-cfssl%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li></ul></footer><div class=share-buttons><p>If this post has been helpful to you, consider <u><a target=_blank href=https://ko-fi.com/mvazce>supporting the work.</a></u></p></div><script src=https://utteranc.es/client.js repo=mvazquezc/mvazquezc.github.io issue-term=pathname label=blog-comments theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=https://linuxera.org/>Linuxera</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>