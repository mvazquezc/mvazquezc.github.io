<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Container Security - Linux Capabilities and Secure Compute Profiles | Linuxera</title><meta name=keywords content="linux,seccomp,containers,kubernetes,capabilities,security,profiles,devsecops"><meta name=description content="Container Security - Linux Capabilities and Secure Compute Profiles In this post we are going to see two security mechanisms used in Linux Containers in order to provide a security layer for our workloads.
We will see how Linux Capabilities and Secure Compute Profiles can be used for limiting the attack surface for our containers.
The first part of the blog post will be an introduction to Linux Capabilities and Secure Compute Profiles, second part will show how these technologies work through the use of demos."><meta name=author content="Mario"><link rel=canonical href=https://linuxera.org/container-security-capabilities-seccomp/><link crossorigin=anonymous href=/assets/css/stylesheet.8cc7ef3cdd44c5188f9267864f378d8dd8892d583e0fd07b5e5321e496f1e4d1.css integrity="sha256-jMfvPN1ExRiPkmeGTzeNjdiJLVg+D9B7XlMh5Jbx5NE=" rel="preload stylesheet" as=style><link rel=icon href=https://linuxera.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://linuxera.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://linuxera.org/favicon-32x32.png><link rel=apple-touch-icon href=https://linuxera.org/apple-touch-icon.png><link rel=mask-icon href=https://linuxera.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=linuxera.org src=https://stats.linuxera.org/js/script.file-downloads.hash.outbound-links.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><meta property="og:title" content="Container Security - Linux Capabilities and Secure Compute Profiles"><meta property="og:description" content="Container Security - Linux Capabilities and Secure Compute Profiles In this post we are going to see two security mechanisms used in Linux Containers in order to provide a security layer for our workloads.
We will see how Linux Capabilities and Secure Compute Profiles can be used for limiting the attack surface for our containers.
The first part of the blog post will be an introduction to Linux Capabilities and Secure Compute Profiles, second part will show how these technologies work through the use of demos."><meta property="og:type" content="article"><meta property="og:url" content="https://linuxera.org/container-security-capabilities-seccomp/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-27T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-27T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Container Security - Linux Capabilities and Secure Compute Profiles"><meta name=twitter:description content="Container Security - Linux Capabilities and Secure Compute Profiles In this post we are going to see two security mechanisms used in Linux Containers in order to provide a security layer for our workloads.
We will see how Linux Capabilities and Secure Compute Profiles can be used for limiting the attack surface for our containers.
The first part of the blog post will be an introduction to Linux Capabilities and Secure Compute Profiles, second part will show how these technologies work through the use of demos."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://linuxera.org/posts/"},{"@type":"ListItem","position":2,"name":"Container Security - Linux Capabilities and Secure Compute Profiles","item":"https://linuxera.org/container-security-capabilities-seccomp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Container Security - Linux Capabilities and Secure Compute Profiles","name":"Container Security - Linux Capabilities and Secure Compute Profiles","description":"Container Security - Linux Capabilities and Secure Compute Profiles In this post we are going to see two security mechanisms used in Linux Containers in order to provide a security layer for our workloads.\nWe will see how Linux Capabilities and Secure Compute Profiles can be used for limiting the attack surface for our containers.\nThe first part of the blog post will be an introduction to Linux Capabilities and Secure Compute Profiles, second part will show how these technologies work through the use of demos.","keywords":["linux","seccomp","containers","kubernetes","capabilities","security","profiles","devsecops"],"articleBody":"Container Security - Linux Capabilities and Secure Compute Profiles In this post we are going to see two security mechanisms used in Linux Containers in order to provide a security layer for our workloads.\nWe will see how Linux Capabilities and Secure Compute Profiles can be used for limiting the attack surface for our containers.\nThe first part of the blog post will be an introduction to Linux Capabilities and Secure Compute Profiles, second part will show how these technologies work through the use of demos.\nLinux Capabilities For the purpose of permission checks, traditional UNIX implementations distinguish two categories of processes:\nPrivileged Processes: Whose effective user ID is 0, referred to as superuser or root. Unprivileged Processes: Whose effective UID is nonzero. Privileged processes bypass all kernel permissions checks, on the other hand, unprivileged processes are subject to full permissions checking based on the processes credentials. Usually effective UID, effective GID and supplementary group list.\nStarting with kernel 2.2, Linux divides the privileges traditionally associated with superuser into distinct units, known as capabilities, which can be independently enabled and disabled.\nYou need to keep in mind that capabilities are a per-thread attribute.\nThe first square represents root without capabilities before Linux kernel 2.2. The second square represents root with full capabilities. The third square represents root with only a few capabilities enabled. We can say that the power of root comes from the capabilities it can use rather than from being root itself. This will be important to understand that even if a container is running as root UID it doesn’t mean that it has full root privileges.\nAt the moment of this writing there are a total of 41 capabilities, you can find the list here. We are going to see some of the most common ones:\nCapability Allows NET_RAW Use RAW and PACKET sockets SETUID Make arbitrary manipulations of process UIDs CHOWN Marke arbitrary changes to file UIDs and GIDs SYS_PTRACE Trace arbitrary processes using ptrace SYS_TIME Set system clock Container runtimes have some of these capabilities enabled by default, for example, you can check the default capabilities enabled by the CRI-O runtime on its version v1.21 here.\nOne potential question you might have could be “What capabilities are required for my application?” - Well, knowing which capabilities are required by your applications requires a very good knowledge of the application by the developer. There is no magic tool that will tell you which capabilities are actually required.\nSecure Compute Profiles (Seccomp) Containers typically run a single application with a set of well-defined tasks, these applications usually require a small subset of the underlying operating system kernel APIs. For example, an httpd server does not require the mount syscall at all, why should the app have access to this syscall?\nIn order to limit the attack vector of a subverted process running in a container, the seccomp Linux kernel feature can be used to limit which syscalls a process has access to. We can think of seccomp like a firewall for syscalls.\nCreating your own seccomp profiles can be tedious and often requires deep knowledge of the application. For example, a developer must be aware that a framework that sets up a network server to accept connections would translate into calling socket, bind and listen system calls. This time, there is some tooling that can help us getting the list of syscalls used by our applications:\noci-seccomp-bpf-hook\nKeep in mind when using the oci hook for creating seccomp profiles for runtimes such as CRI-O that you need to run the hook with the proper container runtime, e.g: crun vs runc. strace\netc\nSecure Compute Profiles can be defined using JSON, below we will see an example:\n{ \"defaultAction\": \"SCMP_ACT_ERRNO\", \"architectures\": [ \"SCMP_ARCH_X86_64\", \"SCMP_ARCH_X86\", \"SCMP_ARCH_X32\" ], \"syscalls\": [ { \"names\": [ \"accept4\", \"epoll_wait\", \"pselect6\", \"futex\" ], \"action\": \"SCMP_ACT_ALLOW\" } ] } Profiles can have multiple actions configured:\nAction Result SCMP_ACT_ALLOW Allows the use of the specified syscalls SCMP_ACT_ERRNO Denies the use of the specified syscalls SCMP_ACT_LOG Allows the use of any syscalls, but logs in the audit log the ones that are not explicitly permitted Above policy can be interpreted as:\nThe default action for syscalls not defined in the seccomp is deny, that means that we will only allow running syscalls explicitly permitted in our policy. The policy applies to the system architectures defined in architectures. We have a group of 4 syscalls that are permitted: accept4, epoll_wait, pselect6 and futex. Linux Capabilities in Action In the previous section on capabilities we said that capabilities are a per-thread attribute, and as such every thread has the following capability sets containing zero or more capabilities:\nPermitted Set Capabilities that the thread may assume. It also limits the capabilities that may be added to the inheritable set by a thread that has the SETPCAP capability in its effective set. If a thread drops a capability from its permitted set, it can never reacquire that capability unless it execve either a SETUID program or a program with that capability set as a permitted file capability. Inheritable Set Capabilities preserved across an execve. Inheritable capabilities remain inheritable when executing any program, and they will be added to the permitted set when executing a program that has that capability set as inheritable file capability. Keep in mind that inheritable capabilities are not generally preserved across execve when running as a non-root user, for such uses cases consider using ambient capabilities. Effective Set Capabilities used by the kernel to perform permission checks for the thread. Bounding Set Used to limit which capabilities can be gained during execve. Ambient Set Capabilities that are preserved across an execve of a program that is not privileged. No capability can ever be ambient if it’s not both permitted and inheritable. Executing a program that changes UID or GID due to SETUID or SETGID bits or executing a program that has file capabilities set will clear the ambient set. Ambient capabilities are added to the permitted set and assigned to the effective set when execve is called. On top of thread capabilities we have file capabilities, which are capabilities assigned to an executable file and that upon execution will be granted to the thread. These file capabilities are stored using one bit, but they act as different file capability sets:\nPermitted Set Capabilities that are automatically permitted to the thread, regardless of the thread’s inheritable capabilities. Inheritable Capabilities that are ANDed with the thread’s inheritable set to determine which inheritable capabilities are enabled in the permitted set of the thread after the execve. Effective This is not a capability set, but rather just a single bit. If set, during an execve all of the thread’s permitted capabilities are also raised in the effective set. If not set, after an execve, none of the thread’s permitted capabilities are raised in the effective set. Enabling a capability in the file effective set implies that the thread will acquire that capability in its permitted set. Capabilities and containers Before we get started with hands-on scenarios we need to know how capabilities behave in containers, specially what’s the different behaviours we get when running a container as root or as a non-root user.\nContainers running with UID 0\nWhen we run a container with UID 0, default capabilities configured by the runtime will be configured in the effective set for the container thread.\nPodman default runtime capabilities can be found here. You can also modify the defaults using the Podman’s configuration file.\nContainer running with nonroot UIDs\nWhen we run a container with a nonroot UID, default capabilities configured by the runtime are dropped, they will be in the inherited set and we can use file capabilities for such cases. We can also explicitly request a list of capabilities to the container runtime so those will be added to the container thread effective set.\nIn the next scenarios we will show the differences.\nGet capabilities assigned to a process During the following scenarios we will get capabilities assigned to processes, there are different ways of getting this information, let’s see some.\nLet’s run a test container, this container has an application that listens on a given port, but that’s not important for now:\npodman run -d --rm --name reversewords-test quay.io/mavazque/reversewords:latest We can always get capabilities for a process by querying the /proc filesystem:\n# Get container's PID CONTAINER_PID=$(podman inspect reversewords-test --format \\{\\{.State.Pid\\}\\}) # Get caps for a given PID grep Cap /proc/${CONTAINER_PID}/status NOTE: The command returns the different capability sets in hex format, we will use a tool to decode that information.\nCapInh:\t00000000800405fb CapPrm:\t00000000800405fb CapEff:\t00000000800405fb CapBnd:\t00000000800405fb CapAmb:\t0000000000000000 We can see that the inherited, permitted, effective and bounding sets share the same capabilities, let’s decode them:\ncapsh --decode=00000000800405fb NOTE: As you can see below capabilities were assigned since those are the runtime’s defaults and our container is running with UID 0 so no capabilities were dropped.\n0x00000000800405fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,cap_setfcap We can use podman inspect as well:\npodman inspect reversewords-test --format \\{\\{.EffectiveCaps\\}\\} [CAP_CHOWN CAP_DAC_OVERRIDE CAP_FOWNER CAP_FSETID CAP_KILL CAP_NET_BIND_SERVICE CAP_SETFCAP CAP_SETGID CAP_SETPCAP CAP_SETUID CAP_SYS_CHROOT] We can stop the test container now:\npodman stop reversewords-test Container running with UID 0 vs container running with nonroot UID We explained the different behaviour between a container running with root’s UID and with nonroot UID, now let’s see it in action.\nRun our test container with a root uid and get it’s capabilities:\n# Run the container podman run --rm -it --user 0 --entrypoint /bin/bash --name reversewords-test quay.io/mavazque/reversewords:ubi8 # Now we're inside the container, let's get caps grep Cap /proc/1/status CapInh:\t00000000800405fb CapPrm:\t00000000800405fb CapEff:\t00000000800405fb CapBnd:\t00000000800405fb CapAmb:\t0000000000000000 We can decode the capabilities in the effective set:\ncapsh --decode=00000000800405fb 0x00000000800405fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,cap_setfcap We can exit our container now:\nexit Now it’s time to run our test container with a nonroot uid:\n# Run the container podman run --rm -it --user 1024 --entrypoint /bin/bash --name reversewords-test quay.io/mavazque/reversewords:ubi8 # Now we're inside the container, let's get caps grep Cap /proc/1/status NOTE: As you can see since we’re running with a nonroot UID our permitted and effective set were cleared. We could still use file capabilities.\nCapInh:\t00000000800405fb CapPrm:\t0000000000000000 CapEff:\t0000000000000000 CapBnd:\t00000000800405fb CapAmb:\t0000000000000000 We can exit our container now:\nexit On top of file capabilities, we can request specific capabilities to the runtime and they will be assigned to the corresponding sets even if we are running with a nonroot uid:\n# Run the container and request the NET_BIND_SERVICE capability podman run --rm -it --user 1024 --cap-add=cap_net_bind_service --entrypoint /bin/bash --name reversewords-test quay.io/mavazque/reversewords:ubi8 # Now we're inside the container, let's get caps grep Cap /proc/1/status NOTE: You can see that we got some capability in the permitted and effective set, let’s decode it.\nCapInh:\t00000000800405fb CapPrm:\t0000000000000400 CapEff:\t0000000000000400 CapBnd:\t00000000800405fb CapAmb:\t0000000000000400 Decode the capability:\ncapsh --decode=0000000000000400 NOTE: As expected, the NET_BIND_SERVICE capability was added to the containers permitted and effective set.\n0x0000000000000400=cap_net_bind_service We can exit our container now:\nexit Real world scenario We said that the power of root comes from its capabilities and not from just being root, in the next scenario we are going to show how we can use capabilities in order to run root-like actions with nonroot users.\nWe have our test application, it runs a small web-service on a given port. We want to bind to port 80, but as you might know, binding to ports under 1024 is a privileged action. Let’s see how capabilities can help us here.\nUsing thread capabilities\nWe can control in which port our application listens by using the APP_PORT environment variable. Let’s try to run our application in a non-privileged port with a non-privileged user:\npodman run --rm --user 1024 -e APP_PORT=8080 --name reversewords-test quay.io/mavazque/reversewords:ubi8 NOTE: As you can see the application is running properly.\n2021/03/27 17:12:49 Starting Reverse Api v0.0.18 Release: NotSet 2021/03/27 17:12:49 Listening on port 8080 You can stop the container by pressing Ctrl+C\nNow, let’s try to bind to port 80\npodman run --rm --user 1024 -e APP_PORT=80 --name reversewords-test quay.io/mavazque/reversewords:ubi8 NOTE: We got a permission denied, if you remember since we’re running with a nonroot UID the capability sets were cleared.\n2021/03/27 17:15:56 Starting Reverse Api v0.0.18 Release: NotSet 2021/03/27 17:15:56 Listening on port 80 2021/03/27 17:15:56 listen tcp :80: bind: permission denied We know that the capability NET_BIND_SERVICE allows unprivileged processes to bind to ports under 1024, let’s assign this capability to the container and see what happens:\npodman run --rm --user 1024 -e APP_PORT=80 --cap-add=cap_net_bind_service --name reversewords-test quay.io/mavazque/reversewords:ubi8 NOTE: Now the application was able to bind to port 80 even if it’s running with a nonroot user because the capability NET_BIND_SERVICE was added to the thread’s effective set.\n2021/03/27 17:18:07 Starting Reverse Api v0.0.18 Release: NotSet 2021/03/27 17:18:07 Listening on port 80 You can stop the container by pressing Ctrl+C\nUsing file capabilities\nFor this example we’re using the same application, but this time we set file capabilities to our application binary using the setcap command:\nNOTE: We added the NET_BIND_SERVICE in the effective and permitted file capability set.\nsetcap 'cap_net_bind_service+ep' /usr/bin/reverse-words Let’s see what happens when we run this new image:\npodman run --rm -it --entrypoint /bin/bash --user 1024 -e APP_PORT=80 --name reversewords-test quay.io/mavazque/reversewords-captest:latest Instead of running the application directly, we opened a shell. Let’s review the file capabilities assigned to our binary:\ngetcap /usr/bin/reverse-words NOTE: As previously mentioned, NET_BIND_SERVICE capability was added.\n/usr/bin/reverse-words = cap_net_bind_service+ep Let’s see the container thread capabilities:\ngrep Cap /proc/1/status NOTE: We don’t have the NET_BIND_SERVICE capability in the effective set, which means that we won’t be able to bind to port 80 under normal circumstances. If we decode the inherited set we will see that the NET_BIND_SERVICE capability is present, that means that we should be able to use file capabilities to get that capability in the effective and permitted set.\nCapInh:\t00000000800405fb CapPrm:\t0000000000000000 CapEff:\t0000000000000000 CapBnd:\t00000000800405fb CapAmb:\t0000000000000000 Let’s try to run our application:\n/usr/bin/reverse-words NOTE: We were able to bind to port 80 since the file capability granted access to NET_BIND_SERVICE to our application thread.\n2021/03/27 17:26:51 Starting Reverse Api v0.0.18 Release: NotSet 2021/03/27 17:26:51 Listening on port 80 We can exit our container now:\nexit You might be thinking that file capabilities can be used to bypass the thread’s capabilities, but that’s not the case. Let’s see what happens when we try to get a capability via file capabilities when the capability we want to get is not in the thread’s inherited set:\n# We explicitly request to drop all capabilities podman run --rm -it --entrypoint /bin/bash --user 1024 --cap-drop=all -e APP_PORT=80 --name reversewords-test quay.io/mavazque/reversewords-captest:latest Let’s see the container thread capabilities:\ngrep Cap /proc/1/status NOTE: We don’t have any capability in any capability set for the thread.\nCapInh:\t0000000000000000 CapPrm:\t0000000000000000 CapEff:\t0000000000000000 CapBnd:\t0000000000000000 CapAmb:\t0000000000000000 If we try to run our application:\nNOTE: The kernel stopped us from getting the NET_BIND_SERVICE and thus executing our app.\nbash: /usr/bin/reverse-words: Operation not permitted We can exit our container now:\nexit Capability aware programs Very similar to file capabilities there are programs that are capability aware, that happens when they use specific libraries that are used for managing capabilities at a thread level.\nIn the previous example, our application raised the NET_BIND_SERVICE capability in the effective set for the whole execution time. Capability aware programs are much smarter and they only raise capabilities when they’re required and they drop those capabilities when they’re no longer required.\nIf our application was that smarter it would’ve raised the NET_BIND_SERVICE before binding to port 80, and once binded it would’ve dropped the capability since it was not required anymore.\nFor example, we can build capability aware programs in go by using a library like this.\nSecure Compute Profiles in Action In this scenario we will generate a seccomp profile for our container, in order to do that we will use the OCI Hook project.\nNOTE: The OCI Hook requires us to run containers with a privileged user, that’s why we will be using sudo in the next commands.\nRun a container that runs ls / command and tell the hook to save the seccomp profile at /tmp/ls.json:\nsudo podman run --rm --annotation io.containers.trace-syscall=\"of:/tmp/ls.json\" fedora:32 ls / \u003e /dev/null The hook generated the seccomp profile at /tmp/ls.json, let’s review it:\ncat /tmp/ls.json | jq NOTE: We can see the syscalls that were made by our container in order to run the ls / command.\n{ \"defaultAction\": \"SCMP_ACT_ERRNO\", \"architectures\": [ \"SCMP_ARCH_X86_64\" ], \"syscalls\": [ { \"names\": [ \"access\", \"arch_prctl\", \"brk\", \"capset\", \"close\", \"execve\", \"exit_group\", \"fstat\", \"getdents64\", \"ioctl\", \"mmap\", \"mprotect\", \"munmap\", \"openat\", \"prctl\", \"pread64\", \"prlimit64\", \"read\", \"rt_sigaction\", \"rt_sigprocmask\", \"select\", \"set_robust_list\", \"set_tid_address\", \"setresgid\", \"setresuid\", \"stat\", \"statfs\", \"write\" ], \"action\": \"SCMP_ACT_ALLOW\", \"args\": [], \"comment\": \"\", \"includes\": {}, \"excludes\": {} } ] } Now that we have a seccomp profile that only has the required syscalls for our application to work, we can run the container with this profile:\npodman run --rm --security-opt seccomp=/tmp/ls.json fedora:32 ls / \u003e /dev/null It worked!, let’s see what happens if we change the ls command a bit:\npodman run --rm --security-opt seccomp=/tmp/ls.json fedora:32 ls -l / \u003e /dev/null NOTE: The ls -l command failed because it requires additional syscalls that are not permitted by our seccomp profile.\nls: cannot access '/': Operation not permitted The hook allow us to pass an input file that will be used as baseline, then we will log the required additional syscalls into a new output file:\nsudo podman run --rm --annotation io.containers.trace-syscall=\"if:/tmp/ls.json;of:/tmp/lsl.json\" fedora:32 ls -l / \u003e /dev/null An updated seccomp profile has been generated at /tmp/lsl.json, let’s compare both profiles:\ndiff \u003c(jq -S . /tmp/ls.json) \u003c(jq -S . /tmp/lsl.json) NOTE: We can see the additional syscalls required by the ls -l command below.\n42a43,61 \u003e }, \u003e { \u003e \"action\": \"SCMP_ACT_ALLOW\", \u003e \"args\": [], \u003e \"comment\": \"\", \u003e \"excludes\": {}, \u003e \"includes\": {}, \u003e \"names\": [ \u003e \"connect\", \u003e \"fcntl\", \u003e \"futex\", \u003e \"getpid\", \u003e \"getxattr\", \u003e \"lgetxattr\", \u003e \"lseek\", \u003e \"lstat\", \u003e \"readlink\", \u003e \"socket\" \u003e ] If we try to use the new seccomp profile we will be able to run the ls -l command this time:\npodman run --rm --security-opt seccomp=/tmp/lsl.json fedora:32 ls -l / \u003e /dev/null Closing Thoughts In this blog post we introduced two security technologies in containers that can be used to limit the attack surface in our applications running in containers. In a future blog post we will see how these technologies can be leveraged in Kubernetes.\nSources Linux Capabilities in OpenShift Linux Man Pages ","wordCount":"3081","inLanguage":"en","datePublished":"2021-03-27T00:00:00Z","dateModified":"2021-03-27T00:00:00Z","author":{"@type":"Person","name":"Mario"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://linuxera.org/container-security-capabilities-seccomp/"},"publisher":{"@type":"Organization","name":"Linuxera","logo":{"@type":"ImageObject","url":"https://linuxera.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://linuxera.org/ accesskey=h title="Linuxera (Alt + H)">Linuxera</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://linuxera.org/ title="🏠 Home"><span>🏠 Home</span></a></li><li><a href=https://linuxera.org/archives/ title="🗄️ Archive"><span>🗄️ Archive</span></a></li><li><a href=https://linuxera.org/search/ title="🔎 Search"><span>🔎 Search</span></a></li><li><a href=https://linuxera.org/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=https://linuxera.org/presentations/ title="🎴 Presentations"><span>🎴 Presentations</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://linuxera.org/>Home</a>&nbsp;»&nbsp;<a href=https://linuxera.org/posts/>Posts</a></div><h1 class=post-title>Container Security - Linux Capabilities and Secure Compute Profiles</h1><div class=post-meta><span title='2021-03-27 00:00:00 +0000 UTC'>Published on March 27, 2021</span>&nbsp;·&nbsp;<span title='2021-03-27 00:00:00 +0000 UTC'>Last updated on March 27, 2021</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Mario</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#container-security---linux-capabilities-and-secure-compute-profiles aria-label="Container Security - Linux Capabilities and Secure Compute Profiles">Container Security - Linux Capabilities and Secure Compute Profiles</a><ul><li><a href=#linux-capabilities aria-label="Linux Capabilities">Linux Capabilities</a></li><li><a href=#secure-compute-profiles-seccomp aria-label="Secure Compute Profiles (Seccomp)">Secure Compute Profiles (Seccomp)</a></li><li><a href=#linux-capabilities-in-action aria-label="Linux Capabilities in Action">Linux Capabilities in Action</a><ul><li><a href=#capabilities-and-containers aria-label="Capabilities and containers">Capabilities and containers</a></li><li><a href=#get-capabilities-assigned-to-a-process aria-label="Get capabilities assigned to a process">Get capabilities assigned to a process</a></li><li><a href=#container-running-with-uid-0-vs-container-running-with-nonroot-uid aria-label="Container running with UID 0 vs container running with nonroot UID">Container running with UID 0 vs container running with nonroot UID</a></li><li><a href=#real-world-scenario aria-label="Real world scenario">Real world scenario</a></li><li><a href=#capability-aware-programs aria-label="Capability aware programs">Capability aware programs</a></li></ul></li><li><a href=#secure-compute-profiles-in-action aria-label="Secure Compute Profiles in Action">Secure Compute Profiles in Action</a></li></ul></li><li><a href=#closing-thoughts aria-label="Closing Thoughts">Closing Thoughts</a></li><li><a href=#sources aria-label=Sources>Sources</a></li></ul></div></details></div><div class=post-content><h1 id=container-security---linux-capabilities-and-secure-compute-profiles>Container Security - Linux Capabilities and Secure Compute Profiles<a hidden class=anchor aria-hidden=true href=#container-security---linux-capabilities-and-secure-compute-profiles>#</a></h1><p>In this post we are going to see two security mechanisms used in Linux Containers in order to provide a security layer for our workloads.</p><p>We will see how Linux Capabilities and Secure Compute Profiles can be used for limiting the attack surface for our containers.</p><p>The first part of the blog post will be an introduction to Linux Capabilities and Secure Compute Profiles, second part will show how these technologies work through the use of demos.</p><h2 id=linux-capabilities>Linux Capabilities<a hidden class=anchor aria-hidden=true href=#linux-capabilities>#</a></h2><p>For the purpose of permission checks, traditional UNIX implementations distinguish two categories of processes:</p><ul><li>Privileged Processes: Whose effective user ID is <code>0</code>, referred to as <em>superuser</em> or <em>root</em>.</li><li>Unprivileged Processes: Whose effective UID is <code>nonzero</code>.</li></ul><p>Privileged processes bypass all kernel permissions checks, on the other hand, unprivileged processes are subject to full permissions checking based on the processes credentials. Usually effective UID, effective GID and supplementary group list.</p><p>Starting with kernel 2.2, Linux divides the privileges traditionally associated with superuser into distinct units, known as <strong>capabilities</strong>, which can be independently enabled and disabled.</p><p>You need to keep in mind that capabilities are a per-thread attribute.</p><p><img loading=lazy src=https://linuxera.org/container-security-capabilities-seccomp/root-capabilities.png alt="root capabilities"></p><ul><li>The first square represents root without capabilities before Linux kernel 2.2.</li><li>The second square represents root with full capabilities.</li><li>The third square represents root with only a few capabilities enabled.</li></ul><p>We can say that the power of root comes from the capabilities it can use rather than from being root itself. This will be important to understand that even if a container is running as root UID it doesn&rsquo;t mean that it has full root privileges.</p><p>At the moment of this writing there are a total of 41 capabilities, you can find the list <a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>here</a>. We are going to see some of the most common ones:</p><table><thead><tr><th>Capability</th><th>Allows</th></tr></thead><tbody><tr><td>NET_RAW</td><td>Use <code>RAW</code> and <code>PACKET</code> sockets</td></tr><tr><td>SETUID</td><td>Make arbitrary manipulations of process UIDs</td></tr><tr><td>CHOWN</td><td>Marke arbitrary changes to file UIDs and GIDs</td></tr><tr><td>SYS_PTRACE</td><td>Trace arbitrary processes using <code>ptrace</code></td></tr><tr><td>SYS_TIME</td><td>Set system clock</td></tr></tbody></table><br><p>Container runtimes have some of these capabilities enabled by default, for example, you can check the default capabilities enabled by the CRI-O runtime on its version v1.21 <a href=https://github.com/cri-o/cri-o/blob/release-1.21/internal/config/capabilities/capabilities.go#L15-L27>here</a>.</p><p>One potential question you might have could be &ldquo;What capabilities are required for my application?&rdquo; - Well, knowing which capabilities are required by your applications requires a very good knowledge of the application by the developer. There is no magic tool that will tell you which capabilities are actually required.</p><h2 id=secure-compute-profiles-seccomp>Secure Compute Profiles (Seccomp)<a hidden class=anchor aria-hidden=true href=#secure-compute-profiles-seccomp>#</a></h2><p>Containers typically run a single application with a set of well-defined tasks, these applications usually require a small subset of the underlying operating system kernel APIs. For example, an <em>httpd</em> server does not require the <a href=https://man7.org/linux/man-pages/man2/mount.2.html>mount <em>syscall</em></a> at all, why should the app have access to this <em>syscall</em>?</p><p>In order to limit the attack vector of a subverted process running in a container, the <em>seccomp</em> Linux kernel feature can be used to limit which <em>syscalls</em> a process has access to. We can think of <em>seccomp</em> like a firewall for <em>syscalls</em>.</p><p>Creating your own <em>seccomp</em> profiles can be tedious and often requires deep knowledge of the application. For example, a developer must be aware that a framework that sets up a network server to accept connections would translate into calling <em>socket</em>, <em>bind</em> and <em>listen</em> system calls. This time, there is some tooling that can help us getting the list of <em>syscalls</em> used by our applications:</p><ul><li><p><a href=https://github.com/containers/oci-seccomp-bpf-hook><em>oci-seccomp-bpf-hook</em></a></p><ul><li>Keep in mind when using the <em>oci</em> hook for creating <em>seccomp</em> profiles for runtimes such as CRI-O that you need to run the hook with the proper container runtime, e.g: <em><code>crun</code></em> vs <em><code>runc</code></em>.</li></ul></li><li><p><a href=https://man7.org/linux/man-pages/man1/strace.1.html>strace</a></p></li><li><p>etc</p></li></ul><p>Secure Compute Profiles can be defined using JSON, below we will see an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;defaultAction&#34;</span><span class=p>:</span> <span class=s2>&#34;SCMP_ACT_ERRNO&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;architectures&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;SCMP_ARCH_X86_64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;SCMP_ARCH_X86&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;SCMP_ARCH_X32&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=nt>&#34;syscalls&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;names&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;accept4&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;epoll_wait&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;pselect6&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=s2>&#34;futex&#34;</span>
</span></span><span class=line><span class=cl>            <span class=p>],</span>
</span></span><span class=line><span class=cl>            <span class=nt>&#34;action&#34;</span><span class=p>:</span> <span class=s2>&#34;SCMP_ACT_ALLOW&#34;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Profiles can have multiple actions configured:</p><table><thead><tr><th>Action</th><th>Result</th></tr></thead><tbody><tr><td>SCMP_ACT_ALLOW</td><td>Allows the use of the specified <em>syscalls</em></td></tr><tr><td>SCMP_ACT_ERRNO</td><td>Denies the use of the specified <em>syscalls</em></td></tr><tr><td>SCMP_ACT_LOG</td><td>Allows the use of any <em>syscalls</em>, but logs in the audit log the ones that are not explicitly permitted</td></tr></tbody></table><br><p>Above policy can be interpreted as:</p><ol><li>The default action for <em>syscalls</em> not defined in the <em>seccomp</em> is deny, that means that we will only allow running <em>syscalls</em> explicitly permitted in our policy.</li><li>The policy applies to the system architectures defined in <code>architectures</code>.</li><li>We have a group of 4 <em>syscalls</em> that are permitted: <code>accept4</code>, <code>epoll_wait</code>, <code>pselect6</code> and <code>futex</code>.</li></ol><h2 id=linux-capabilities-in-action>Linux Capabilities in Action<a hidden class=anchor aria-hidden=true href=#linux-capabilities-in-action>#</a></h2><p>In the previous section on capabilities we said that capabilities are a per-thread attribute, and as such every thread has the following capability sets containing zero or more capabilities:</p><ul><li>Permitted Set<ul><li>Capabilities that the thread may assume. It also limits the capabilities that may be added to the inheritable set by a thread that has the <strong>SETPCAP</strong> capability in its effective set. If a thread drops a capability from its permitted set, it can never reacquire that capability unless it <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong> either a SETUID program or a program with that capability set as a permitted file capability.</li></ul></li><li>Inheritable Set<ul><li>Capabilities preserved across an <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong>. Inheritable capabilities remain inheritable when executing any program, and they will be added to the permitted set when executing a program that has that capability set as inheritable file capability. Keep in mind that inheritable capabilities are not generally preserved across <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong> when running as a non-root user, for such uses cases consider using ambient capabilities.</li></ul></li><li>Effective Set<ul><li>Capabilities used by the kernel to perform permission checks for the thread.</li></ul></li><li>Bounding Set<ul><li>Used to limit which capabilities can be gained during <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong>.</li></ul></li><li>Ambient Set<ul><li>Capabilities that are preserved across an <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong> of a program that is not privileged. No capability can ever be ambient if it&rsquo;s not both permitted and inheritable. Executing a program that changes UID or GID due to SETUID or SETGID bits or executing a program that has file capabilities set will clear the ambient set. Ambient capabilities are added to the permitted set and assigned to the effective set when <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong> is called.</li></ul></li></ul><p>On top of <strong>thread capabilities</strong> we have <strong>file capabilities</strong>, which are capabilities assigned to an executable file and that upon execution will be granted to the thread. These file capabilities are stored using one bit, but they act as different file capability sets:</p><ul><li>Permitted Set<ul><li>Capabilities that are automatically permitted to the thread, regardless of the thread&rsquo;s inheritable capabilities.</li></ul></li><li>Inheritable<ul><li>Capabilities that are ANDed with the thread&rsquo;s inheritable set to determine which inheritable capabilities are enabled in the permitted set of the thread after the <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong>.</li></ul></li><li>Effective<ul><li>This is not a capability set, but rather just a single bit. If set, during an <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong> all of the thread&rsquo;s permitted capabilities are also raised in the effective set. If not set, after an <strong><a href=https://man7.org/linux/man-pages/man2/execve.2.html>execve</a></strong>, none of the thread&rsquo;s permitted capabilities are raised in the effective set. Enabling a capability in the file effective set implies that the thread will acquire that capability in its permitted set.</li></ul></li></ul><h3 id=capabilities-and-containers>Capabilities and containers<a hidden class=anchor aria-hidden=true href=#capabilities-and-containers>#</a></h3><p>Before we get started with hands-on scenarios we need to know how capabilities behave in containers, specially what&rsquo;s the different behaviours we get when running a container as root or as a non-root user.</p><p><strong>Containers running with UID 0</strong></p><p>When we run a container with UID 0, default capabilities configured by the runtime will be configured in the <code>effective</code> set for the container thread.</p><p>Podman default runtime capabilities can be found <a href=https://github.com/containers/common/blob/v0.33.1/pkg/config/default.go#L62-L77>here</a>. You can also modify the defaults using the <a href=https://github.com/containers/common/blob/master/docs/containers.conf.5.md#containers-table>Podman&rsquo;s configuration file</a>.</p><p><strong>Container running with nonroot UIDs</strong></p><p>When we run a container with a nonroot UID, default capabilities configured by the runtime are dropped, they will be in the <code>inherited</code> set and we can use file capabilities for such cases. We can also explicitly request a list of capabilities to the container runtime so those will be added to the container thread <code>effective</code> set.</p><p>In the next scenarios we will show the differences.</p><h3 id=get-capabilities-assigned-to-a-process>Get capabilities assigned to a process<a hidden class=anchor aria-hidden=true href=#get-capabilities-assigned-to-a-process>#</a></h3><p>During the following scenarios we will get capabilities assigned to processes, there are different ways of getting this information, let&rsquo;s see some.</p><ol><li><p>Let&rsquo;s run a test container, this container has an application that listens on a given port, but that&rsquo;s not important for now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run -d --rm --name reversewords-test quay.io/mavazque/reversewords:latest
</span></span></code></pre></div></li><li><p>We can always get capabilities for a process by querying the <code>/proc</code> filesystem:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Get container&#39;s PID</span>
</span></span><span class=line><span class=cl><span class=nv>CONTAINER_PID</span><span class=o>=</span><span class=k>$(</span>podman inspect reversewords-test --format <span class=se>\{\{</span>.State.Pid<span class=se>\}\}</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c1># Get caps for a given PID</span>
</span></span><span class=line><span class=cl>grep Cap /proc/<span class=si>${</span><span class=nv>CONTAINER_PID</span><span class=si>}</span>/status
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: The command returns the different capability sets in hex format, we will use a tool to decode that information.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>CapInh:	00000000800405fb
</span></span><span class=line><span class=cl>CapPrm:	00000000800405fb
</span></span><span class=line><span class=cl>CapEff:	00000000800405fb
</span></span><span class=line><span class=cl>CapBnd:	00000000800405fb
</span></span><span class=line><span class=cl>CapAmb:	<span class=m>0000000000000000</span>
</span></span></code></pre></div></li><li><p>We can see that the <code>inherited</code>, <code>permitted</code>, <code>effective</code> and <code>bounding</code> sets share the same capabilities, let&rsquo;s decode them:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>capsh --decode<span class=o>=</span>00000000800405fb
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: As you can see below capabilities were assigned since those are the <a href=https://github.com/containers/common/blob/v0.33.1/pkg/config/default.go#L62-L77>runtime&rsquo;s defaults</a> and our container is running with UID 0 so no capabilities were dropped.</p></blockquote><pre tabindex=0><code>0x00000000800405fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,cap_setfcap
</code></pre></li><li><p>We can use <code>podman inspect</code> as well:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman inspect reversewords-test --format <span class=se>\{\{</span>.EffectiveCaps<span class=se>\}\}</span>
</span></span></code></pre></div><pre tabindex=0><code>[CAP_CHOWN CAP_DAC_OVERRIDE CAP_FOWNER CAP_FSETID CAP_KILL CAP_NET_BIND_SERVICE CAP_SETFCAP CAP_SETGID CAP_SETPCAP CAP_SETUID CAP_SYS_CHROOT]
</code></pre></li><li><p>We can stop the test container now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman stop reversewords-test
</span></span></code></pre></div></li></ol><h3 id=container-running-with-uid-0-vs-container-running-with-nonroot-uid>Container running with UID 0 vs container running with nonroot UID<a hidden class=anchor aria-hidden=true href=#container-running-with-uid-0-vs-container-running-with-nonroot-uid>#</a></h3><p>We explained the different behaviour between a container running with root&rsquo;s UID and with nonroot UID, now let&rsquo;s see it in action.</p><ol><li><p>Run our test container with a root uid and get it&rsquo;s capabilities:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Run the container</span>
</span></span><span class=line><span class=cl>podman run --rm -it --user <span class=m>0</span> --entrypoint /bin/bash --name reversewords-test quay.io/mavazque/reversewords:ubi8 
</span></span><span class=line><span class=cl><span class=c1># Now we&#39;re inside the container, let&#39;s get caps</span>
</span></span><span class=line><span class=cl>grep Cap /proc/1/status
</span></span></code></pre></div><pre tabindex=0><code>CapInh:	00000000800405fb
CapPrm:	00000000800405fb
CapEff:	00000000800405fb
CapBnd:	00000000800405fb
CapAmb:	0000000000000000
</code></pre></li><li><p>We can decode the capabilities in the <code>effective</code> set:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>capsh --decode<span class=o>=</span>00000000800405fb
</span></span></code></pre></div><pre tabindex=0><code>0x00000000800405fb=cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_sys_chroot,cap_setfcap
</code></pre></li><li><p>We can exit our container now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div></li><li><p>Now it&rsquo;s time to run our test container with a nonroot uid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Run the container</span>
</span></span><span class=line><span class=cl>podman run --rm -it --user <span class=m>1024</span> --entrypoint /bin/bash --name reversewords-test quay.io/mavazque/reversewords:ubi8 
</span></span><span class=line><span class=cl><span class=c1># Now we&#39;re inside the container, let&#39;s get caps</span>
</span></span><span class=line><span class=cl>grep Cap /proc/1/status
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: As you can see since we&rsquo;re running with a nonroot UID our <code>permitted</code> and <code>effective</code> set were cleared. We could still use file capabilities.</p></blockquote><pre tabindex=0><code>CapInh:	00000000800405fb
CapPrm:	0000000000000000
CapEff:	0000000000000000
CapBnd:	00000000800405fb
CapAmb:	0000000000000000
</code></pre></li><li><p>We can exit our container now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div></li><li><p>On top of file capabilities, we can request specific capabilities to the runtime and they will be assigned to the corresponding sets even if we are running with a nonroot uid:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Run the container and request the NET_BIND_SERVICE capability</span>
</span></span><span class=line><span class=cl>podman run --rm -it --user <span class=m>1024</span> --cap-add<span class=o>=</span>cap_net_bind_service --entrypoint /bin/bash --name reversewords-test quay.io/mavazque/reversewords:ubi8
</span></span><span class=line><span class=cl><span class=c1># Now we&#39;re inside the container, let&#39;s get caps</span>
</span></span><span class=line><span class=cl>grep Cap /proc/1/status
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: You can see that we got some capability in the <code>permitted</code> and <code>effective</code> set, let&rsquo;s decode it.</p></blockquote><pre tabindex=0><code>CapInh:	00000000800405fb
CapPrm:	0000000000000400
CapEff:	0000000000000400
CapBnd:	00000000800405fb
CapAmb:	0000000000000400
</code></pre></li><li><p>Decode the capability:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>capsh --decode<span class=o>=</span><span class=m>0000000000000400</span>
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: As expected, the NET_BIND_SERVICE capability was added to the containers <code>permitted</code> and <code>effective</code> set.</p></blockquote><pre tabindex=0><code>0x0000000000000400=cap_net_bind_service
</code></pre></li><li><p>We can exit our container now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div></li></ol><h3 id=real-world-scenario>Real world scenario<a hidden class=anchor aria-hidden=true href=#real-world-scenario>#</a></h3><p>We said that the power of root comes from its capabilities and not from just being root, in the next scenario we are going to show how we can use capabilities in order to run root-like actions with nonroot users.</p><p>We have our test application, it runs a small web-service on a given port. We want to bind to port 80, but as you might know, binding to ports under 1024 is a privileged action. Let&rsquo;s see how capabilities can help us here.</p><p><strong>Using thread capabilities</strong></p><ol><li><p>We can control in which port our application listens by using the <code>APP_PORT</code> environment variable. Let&rsquo;s try to run our application in a non-privileged port with a non-privileged user:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run --rm --user <span class=m>1024</span> -e <span class=nv>APP_PORT</span><span class=o>=</span><span class=m>8080</span> --name reversewords-test quay.io/mavazque/reversewords:ubi8
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: As you can see the application is running properly.</p></blockquote><pre tabindex=0><code>2021/03/27 17:12:49 Starting Reverse Api v0.0.18 Release: NotSet
2021/03/27 17:12:49 Listening on port 8080
</code></pre></li><li><p>You can stop the container by pressing <code>Ctrl+C</code></p></li><li><p>Now, let&rsquo;s try to bind to port 80</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run --rm --user <span class=m>1024</span> -e <span class=nv>APP_PORT</span><span class=o>=</span><span class=m>80</span> --name reversewords-test quay.io/mavazque/reversewords:ubi8
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: We got a permission denied, if you remember since we&rsquo;re running with a nonroot UID the capability sets were cleared.</p></blockquote><pre tabindex=0><code>2021/03/27 17:15:56 Starting Reverse Api v0.0.18 Release: NotSet
2021/03/27 17:15:56 Listening on port 80
2021/03/27 17:15:56 listen tcp :80: bind: permission denied
</code></pre></li><li><p>We know that the capability <code>NET_BIND_SERVICE</code> allows unprivileged processes to bind to ports under 1024, let&rsquo;s assign this capability to the container and see what happens:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run --rm --user <span class=m>1024</span> -e <span class=nv>APP_PORT</span><span class=o>=</span><span class=m>80</span> --cap-add<span class=o>=</span>cap_net_bind_service --name reversewords-test quay.io/mavazque/reversewords:ubi8
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: Now the application was able to bind to port 80 even if it&rsquo;s running with a nonroot user because the capability <code>NET_BIND_SERVICE</code> was added to the thread&rsquo;s effective set.</p></blockquote><pre tabindex=0><code>2021/03/27 17:18:07 Starting Reverse Api v0.0.18 Release: NotSet
2021/03/27 17:18:07 Listening on port 80
</code></pre></li><li><p>You can stop the container by pressing <code>Ctrl+C</code></p></li></ol><p><strong>Using file capabilities</strong></p><p>For this example we&rsquo;re using the same application, but this time we set file capabilities to our application binary using the <code>setcap</code> command:</p><blockquote><p><strong>NOTE</strong>: We added the <code>NET_BIND_SERVICE</code> in the <code>effective</code> and <code>permitted</code> file capability set.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>setcap <span class=s1>&#39;cap_net_bind_service+ep&#39;</span> /usr/bin/reverse-words
</span></span></code></pre></div><ol><li><p>Let&rsquo;s see what happens when we run this new image:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run --rm -it --entrypoint /bin/bash --user <span class=m>1024</span> -e <span class=nv>APP_PORT</span><span class=o>=</span><span class=m>80</span> --name reversewords-test quay.io/mavazque/reversewords-captest:latest
</span></span></code></pre></div></li><li><p>Instead of running the application directly, we opened a shell. Let&rsquo;s review the file capabilities assigned to our binary:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>getcap /usr/bin/reverse-words 
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: As previously mentioned, <code>NET_BIND_SERVICE</code> capability was added.</p></blockquote><pre tabindex=0><code>/usr/bin/reverse-words = cap_net_bind_service+ep
</code></pre></li><li><p>Let&rsquo;s see the container thread capabilities:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>grep Cap /proc/1/status 
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: We don&rsquo;t have the <code>NET_BIND_SERVICE</code> capability in the effective set, which means that we won&rsquo;t be able to bind to port 80 under normal circumstances. If we decode the <code>inherited</code> set we will see that the <code>NET_BIND_SERVICE</code> capability is present, that means that we should be able to use file capabilities to get that capability in the <code>effective</code> and <code>permitted</code> set.</p></blockquote><pre tabindex=0><code>CapInh:	00000000800405fb
CapPrm:	0000000000000000
CapEff:	0000000000000000
CapBnd:	00000000800405fb
CapAmb:	0000000000000000
</code></pre></li><li><p>Let&rsquo;s try to run our application:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>/usr/bin/reverse-words
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: We were able to bind to port 80 since the file capability granted access to <code>NET_BIND_SERVICE</code> to our application thread.</p></blockquote><pre tabindex=0><code>2021/03/27 17:26:51 Starting Reverse Api v0.0.18 Release: NotSet
2021/03/27 17:26:51 Listening on port 80
</code></pre></li><li><p>We can exit our container now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div></li><li><p>You might be thinking that file capabilities can be used to bypass the thread&rsquo;s capabilities, but that&rsquo;s not the case. Let&rsquo;s see what happens when we try to get a capability via file capabilities when the capability we want to get is not in the thread&rsquo;s <code>inherited</code> set:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># We explicitly request to drop all capabilities</span>
</span></span><span class=line><span class=cl>podman run --rm -it --entrypoint /bin/bash --user <span class=m>1024</span> --cap-drop<span class=o>=</span>all -e <span class=nv>APP_PORT</span><span class=o>=</span><span class=m>80</span> --name reversewords-test quay.io/mavazque/reversewords-captest:latest
</span></span></code></pre></div></li><li><p>Let&rsquo;s see the container thread capabilities:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>grep Cap /proc/1/status 
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: We don&rsquo;t have any capability in any capability set for the thread.</p></blockquote><pre tabindex=0><code>CapInh:	0000000000000000
CapPrm:	0000000000000000
CapEff:	0000000000000000
CapBnd:	0000000000000000
CapAmb:	0000000000000000
</code></pre></li><li><p>If we try to run our application:</p><blockquote><p><strong>NOTE</strong>: The kernel stopped us from getting the <code>NET_BIND_SERVICE</code> and thus executing our app.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>bash: /usr/bin/reverse-words: Operation not permitted
</span></span></code></pre></div></li><li><p>We can exit our container now:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div></li></ol><h3 id=capability-aware-programs>Capability aware programs<a hidden class=anchor aria-hidden=true href=#capability-aware-programs>#</a></h3><p>Very similar to file capabilities there are programs that are capability aware, that happens when they use specific libraries that are used for managing capabilities at a thread level.</p><p>In the previous example, our application raised the <code>NET_BIND_SERVICE</code> capability in the <code>effective</code> set for the whole execution time. Capability aware programs are much smarter and they only raise capabilities when they&rsquo;re required and they drop those capabilities when they&rsquo;re no longer required.</p><p>If our application was that smarter it would&rsquo;ve raised the <code>NET_BIND_SERVICE</code> before binding to port 80, and once binded it would&rsquo;ve dropped the capability since it was not required anymore.</p><p>For example, we can build capability aware programs in go by using a library like <a href=https://pkg.go.dev/kernel.org/pub/linux/libs/security/libcap/cap>this</a>.</p><h2 id=secure-compute-profiles-in-action>Secure Compute Profiles in Action<a hidden class=anchor aria-hidden=true href=#secure-compute-profiles-in-action>#</a></h2><p>In this scenario we will generate a <code>seccomp</code> profile for our container, in order to do that we will use the <a href=https://github.com/containers/oci-seccomp-bpf-hook>OCI Hook project</a>.</p><blockquote><p><strong>NOTE</strong>: The <code>OCI Hook</code> requires us to run containers with a privileged user, that&rsquo;s why we will be using <code>sudo</code> in the next commands.</p></blockquote><ol><li><p>Run a container that runs <code>ls /</code> command and tell the hook to save the <code>seccomp</code> profile at <code>/tmp/ls.json</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo podman run --rm --annotation io.containers.trace-syscall<span class=o>=</span><span class=s2>&#34;of:/tmp/ls.json&#34;</span> fedora:32 ls / &gt; /dev/null
</span></span></code></pre></div></li><li><p>The hook generated the <code>seccomp</code> profile at <code>/tmp/ls.json</code>, let&rsquo;s review it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat /tmp/ls.json <span class=p>|</span> jq
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: We can see the <code>syscalls</code> that were made by our container in order to run the <code>ls /</code> command.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-json data-lang=json><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;defaultAction&#34;</span><span class=p>:</span> <span class=s2>&#34;SCMP_ACT_ERRNO&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;architectures&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;SCMP_ARCH_X86_64&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>],</span>
</span></span><span class=line><span class=cl>  <span class=nt>&#34;syscalls&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;names&#34;</span><span class=p>:</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;access&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;arch_prctl&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;brk&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;capset&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;close&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;execve&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;exit_group&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;fstat&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;getdents64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;ioctl&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;mmap&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;mprotect&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;munmap&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;openat&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;prctl&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;pread64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;prlimit64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;read&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;rt_sigaction&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;rt_sigprocmask&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;select&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;set_robust_list&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;set_tid_address&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;setresgid&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;setresuid&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;stat&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;statfs&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;write&#34;</span>
</span></span><span class=line><span class=cl>      <span class=p>],</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;action&#34;</span><span class=p>:</span> <span class=s2>&#34;SCMP_ACT_ALLOW&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;args&#34;</span><span class=p>:</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;comment&#34;</span><span class=p>:</span> <span class=s2>&#34;&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;includes&#34;</span><span class=p>:</span> <span class=p>{},</span>
</span></span><span class=line><span class=cl>      <span class=nt>&#34;excludes&#34;</span><span class=p>:</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p>Now that we have a <code>seccomp</code> profile that only has the required syscalls for our application to work, we can run the container with this profile:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run --rm --security-opt <span class=nv>seccomp</span><span class=o>=</span>/tmp/ls.json fedora:32 ls / &gt; /dev/null
</span></span></code></pre></div></li><li><p>It worked!, let&rsquo;s see what happens if we change the <code>ls</code> command a bit:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run --rm --security-opt <span class=nv>seccomp</span><span class=o>=</span>/tmp/ls.json fedora:32 ls -l / &gt; /dev/null
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: The <code>ls -l</code> command failed because it requires additional <code>syscalls</code> that are not permitted by our <code>seccomp</code> profile.</p></blockquote><pre tabindex=0><code>ls: cannot access &#39;/&#39;: Operation not permitted
</code></pre></li><li><p>The hook allow us to pass an input file that will be used as baseline, then we will log the required additional syscalls into a new output file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo podman run --rm --annotation io.containers.trace-syscall<span class=o>=</span><span class=s2>&#34;if:/tmp/ls.json;of:/tmp/lsl.json&#34;</span> fedora:32 ls -l / &gt; /dev/null
</span></span></code></pre></div></li><li><p>An updated <code>seccomp</code> profile has been generated at <code>/tmp/lsl.json</code>, let&rsquo;s compare both profiles:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>diff &lt;<span class=o>(</span>jq -S . /tmp/ls.json<span class=o>)</span> &lt;<span class=o>(</span>jq -S . /tmp/lsl.json<span class=o>)</span>
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: We can see the additional <code>syscalls</code> required by the <code>ls -l</code> command below.</p></blockquote><pre tabindex=0><code>42a43,61
&gt;     },
&gt;     {
&gt;       &#34;action&#34;: &#34;SCMP_ACT_ALLOW&#34;,
&gt;       &#34;args&#34;: [],
&gt;       &#34;comment&#34;: &#34;&#34;,
&gt;       &#34;excludes&#34;: {},
&gt;       &#34;includes&#34;: {},
&gt;       &#34;names&#34;: [
&gt;         &#34;connect&#34;,
&gt;         &#34;fcntl&#34;,
&gt;         &#34;futex&#34;,
&gt;         &#34;getpid&#34;,
&gt;         &#34;getxattr&#34;,
&gt;         &#34;lgetxattr&#34;,
&gt;         &#34;lseek&#34;,
&gt;         &#34;lstat&#34;,
&gt;         &#34;readlink&#34;,
&gt;         &#34;socket&#34;
&gt;       ]
</code></pre></li><li><p>If we try to use the new <code>seccomp</code> profile we will be able to run the <code>ls -l</code> command this time:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>podman run --rm --security-opt <span class=nv>seccomp</span><span class=o>=</span>/tmp/lsl.json fedora:32 ls -l / &gt; /dev/null
</span></span></code></pre></div></li></ol><h1 id=closing-thoughts>Closing Thoughts<a hidden class=anchor aria-hidden=true href=#closing-thoughts>#</a></h1><p>In this blog post we introduced two security technologies in containers that can be used to limit the attack surface in our applications running in containers. In a future blog post we will see how these technologies can be leveraged in Kubernetes.</p><h1 id=sources>Sources<a hidden class=anchor aria-hidden=true href=#sources>#</a></h1><ul><li><a href=https://www.openshift.com/blog/linux-capabilities-in-openshift>Linux Capabilities in OpenShift</a></li><li><a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>Linux Man Pages</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://linuxera.org/tags/linux/>linux</a></li><li><a href=https://linuxera.org/tags/seccomp/>seccomp</a></li><li><a href=https://linuxera.org/tags/containers/>containers</a></li><li><a href=https://linuxera.org/tags/kubernetes/>kubernetes</a></li><li><a href=https://linuxera.org/tags/capabilities/>capabilities</a></li><li><a href=https://linuxera.org/tags/security/>security</a></li><li><a href=https://linuxera.org/tags/profiles/>profiles</a></li><li><a href=https://linuxera.org/tags/devsecops/>devsecops</a></li></ul><nav class=paginav><a class=prev href=https://linuxera.org/capabilities-seccomp-kubernetes/><span class=title>« Prev</span><br><span>Capabilities and Seccomp Profiles on Kubernetes</span></a>
<a class=next href=https://linuxera.org/containers-under-the-hood/><span class=title>Next »</span><br><span>Containers under the Hood</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Container Security - Linux Capabilities and Secure Compute Profiles on twitter" href="https://twitter.com/intent/tweet/?text=Container%20Security%20-%20Linux%20Capabilities%20and%20Secure%20Compute%20Profiles&url=https%3a%2f%2flinuxera.org%2fcontainer-security-capabilities-seccomp%2f&hashtags=linux%2cseccomp%2ccontainers%2ckubernetes%2ccapabilities%2csecurity%2cprofiles%2cdevsecops"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Container Security - Linux Capabilities and Secure Compute Profiles on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2flinuxera.org%2fcontainer-security-capabilities-seccomp%2f&title=Container%20Security%20-%20Linux%20Capabilities%20and%20Secure%20Compute%20Profiles&summary=Container%20Security%20-%20Linux%20Capabilities%20and%20Secure%20Compute%20Profiles&source=https%3a%2f%2flinuxera.org%2fcontainer-security-capabilities-seccomp%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer><div class=share-buttons><p>If this post has been helpful to you, consider <u><a target=_blank href=https://ko-fi.com/mvazce>supporting the work.</a></u></p></div><script src=https://utteranc.es/client.js repo=mvazquezc/mvazquezc.github.io issue-term=pathname label=blog-comments theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://linuxera.org/>Linuxera</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>