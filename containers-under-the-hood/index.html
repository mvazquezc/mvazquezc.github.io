<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Containers under the Hood | Linuxera</title><meta name=keywords content="containers,linux,namespaces,nsenter,unshare,kernel,selinux"><meta name=description content="Containers are Linux You probably already heard this expression, in today&rsquo;s post we are going to desmitify container technologies by decomposing them part by part and describing which Linux technologies make containers possible.
We can describe a container as an isolated process running on a host. In order to isolate the process the container runtimes leverage Linux kernel technologies such as: namespaces, chroots, cgroups, etc. plus security layers like SELinux."><meta name=author content="Mario"><link rel=canonical href=https://linuxera.org/containers-under-the-hood/><link crossorigin=anonymous href=/assets/css/stylesheet.8cc7ef3cdd44c5188f9267864f378d8dd8892d583e0fd07b5e5321e496f1e4d1.css integrity="sha256-jMfvPN1ExRiPkmeGTzeNjdiJLVg+D9B7XlMh5Jbx5NE=" rel="preload stylesheet" as=style><link rel=icon href=https://linuxera.org/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://linuxera.org/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://linuxera.org/favicon-32x32.png><link rel=apple-touch-icon href=https://linuxera.org/apple-touch-icon.png><link rel=mask-icon href=https://linuxera.org/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script defer data-domain=linuxera.org src=https://stats.linuxera.org/js/script.file-downloads.hash.outbound-links.js></script>
<script>window.plausible=window.plausible||function(){(window.plausible.q=window.plausible.q||[]).push(arguments)}</script><meta property="og:title" content="Containers under the Hood"><meta property="og:description" content="Containers are Linux You probably already heard this expression, in today&rsquo;s post we are going to desmitify container technologies by decomposing them part by part and describing which Linux technologies make containers possible.
We can describe a container as an isolated process running on a host. In order to isolate the process the container runtimes leverage Linux kernel technologies such as: namespaces, chroots, cgroups, etc. plus security layers like SELinux."><meta property="og:type" content="article"><meta property="og:url" content="https://linuxera.org/containers-under-the-hood/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-25T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-25T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Containers under the Hood"><meta name=twitter:description content="Containers are Linux You probably already heard this expression, in today&rsquo;s post we are going to desmitify container technologies by decomposing them part by part and describing which Linux technologies make containers possible.
We can describe a container as an isolated process running on a host. In order to isolate the process the container runtimes leverage Linux kernel technologies such as: namespaces, chroots, cgroups, etc. plus security layers like SELinux."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://linuxera.org/posts/"},{"@type":"ListItem","position":2,"name":"Containers under the Hood","item":"https://linuxera.org/containers-under-the-hood/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Containers under the Hood","name":"Containers under the Hood","description":"Containers are Linux You probably already heard this expression, in today\u0026rsquo;s post we are going to desmitify container technologies by decomposing them part by part and describing which Linux technologies make containers possible.\nWe can describe a container as an isolated process running on a host. In order to isolate the process the container runtimes leverage Linux kernel technologies such as: namespaces, chroots, cgroups, etc. plus security layers like SELinux.","keywords":["containers","linux","namespaces","nsenter","unshare","kernel","selinux"],"articleBody":"Containers are Linux You probably already heard this expression, in today’s post we are going to desmitify container technologies by decomposing them part by part and describing which Linux technologies make containers possible.\nWe can describe a container as an isolated process running on a host. In order to isolate the process the container runtimes leverage Linux kernel technologies such as: namespaces, chroots, cgroups, etc. plus security layers like SELinux.\nWe will see how we can leverage these technologies on Linux in order to build and run our own containers.\nContainer File Systems (a.k.a rootfs) Whenever you pull an image container from a container registry, you’re downloading just a tarball. We can say container images are just tarballs.\nThere are multiple ways to get a rootfs that we can use in order to run our containers, for this blogpost we’re going to download an already built rootfs for Alpine Linux.\nThere are tools such as buildroot that make it really easy to create our own rootfs. We will see how to create our own rootfs using buildroot on a future post.\nAs earlier mentioned, let’s download the x86_64 rootfs for Alpine Linux:\nmkdir /var/tmp/alpine-rootfs/ \u0026\u0026 cd $_ curl https://dl-cdn.alpinelinux.org/alpine/v3.12/releases/x86_64/alpine-minirootfs-3.12.3-x86_64.tar.gz -o rootfs.tar.gz We can extract the rootfs on the temporary folder we just created:\ntar xfz rootfs.tar.gz \u0026\u0026 rm -f rootfs.tar.gz If we take a look at the extracted files:\ntree -L 1 As you can see, the result looks like a Linux system. We have some well known directories in the Linux Filesystem Hierarchy Standard such as: bin, tmp, dev, opt, etc.\n. ├── bin ├── dev ├── etc ├── home ├── lib ├── media ├── mnt ├── opt ├── proc ├── root ├── run ├── sbin ├── srv ├── sys ├── tmp ├── usr └── var chroot Chroot is an operation that changes the root directory for the current running process and their children. A process that runs inside a chroot cannot access files and commands outside the chrooted directory tree.\nThat being said, we can now chroot into the rootfs environment we extracted in the previous step and run a shell to poke around:\nCreate the chroot jail\nsudo chroot /var/tmp/alpine-rootfs/ /bin/sh Check the os-release\ncat /etc/os-release NAME=\"Alpine Linux\" ID=alpine VERSION_ID=3.12.3 PRETTY_NAME=\"Alpine Linux v3.12\" HOME_URL=\"https://alpinelinux.org/\" BUG_REPORT_URL=\"https://bugs.alpinelinux.org/\" Try to list /tmp/alpine-rootfs folder\nls /var/tmp/alpine-rootfs ls: /var/tmp/alpine-rootfs: No such file or directory As you can see we only have visibility of the contents of the rootfs we’ve chroot into.\nWe can now install python and run a simple http server for example:\nInstall python3\napk add python3 Run a simple http server\nNOTE: When we execute the Python interpreter we’re actually running it from /var/tmp/alpine-rootfs/usr/bin/python3\npython3 -m http.server If you open a new shell on your system (even if it’s outside of the chroot) you will be able to reach the http server we just created:\ncurl http://127.0.0.1:8000 namespaces At this point we were able to work with a tarball like if it was a different system, but we’re not isolating the processed from the host system like containers do.\nLet’s check the level of isolation:\nIn a shell outside the chroot run a ping command:\nping 127.0.0.1 Mount the proc filesystem inside the chrooted shell\nNOTE: If you’re still running the python http server you can kill the process\nmount -t proc proc /proc Run a ps command inside the chroot and try to find the ping command:\nps -ef | grep \"ping 127.0.0.1\" 387870 1000 0:00 ping 127.0.0.1 388204 root 0:00 grep ping 127.0.0.1 We have visibility over the host system processes, that’s not great. On top of that, our chroot is running as root so we can even kill the process:\npkill -f \"ping 127.0.0.1\" Now is when we introduce namespaces.\nLinux namespaces are a feature of the Linux kernel that partitions kernel resources so one process will only see a set of resources while a different process can see a different set of resources.\nThese resources may exist in multiple spaces. The list of existing namespaces are:\nNamespace Isolates Cgroup Cgroup root directory IPC System V IPC, POSIX message queues Network Network devices, stacks, prots, etc. Mount Mount points PID Process IDs Time Boot and monotonic clocks User User and Group IDs UTS Hostname and NIS domain name Creating namespaces with unshare Creating namespaces is just a single syscall (unshare). There is also a unshare command line tool that provides a nice wrapper around the syscall.\nWe are going to use the unshare command line to create namespaces manually. Below example will create a PID namespace for the chrooted shell:\nExit the chroot we have already running\nNOTE: Run below command on the chrooted shell\nexit Create the PID namespace and run the chrooted shell inside the namespace\nsudo unshare -p -f --mount-proc=/var/tmp/alpine-rootfs/proc chroot /var/tmp/alpine-rootfs/ /bin/sh Now that we have created our new process namespace, we will see that our shell thinks its PID is 1:\nps -ef NOTE: As you can see, we no longer see the host system processes\nPID USER TIME COMMAND 1 root 0:00 /bin/sh 2 root 0:00 ps -ef Since we didn’t create a namespace for the network we can still see the whole network stack from the host system:\nip -o a NOTE: Below output might vary on your system\n1: lo inet 127.0.0.1/8 scope host lo\\ valid_lft forever preferred_lft forever 1: lo inet6 ::1/128 scope host \\ valid_lft forever preferred_lft forever 4: wlp82s0 inet 192.168.0.160/24 brd 192.168.0.255 scope global dynamic wlp82s0\\ valid_lft 6555sec preferred_lft 6555sec 4: wlp82s0 inet6 fe80::4e03:6176:40f0:b862/64 scope link \\ valid_lft forever preferred_lft forever Entering namespaces with nsenter One powerful thing about namespaces is that they’re pretty flexible, for example you can have processes with some separated namespaces and some shared namespaces. One example in the Kubernetes world will be containers running in pods: Containers will have different PID namespaces but they will share the Network namespace.\nThere is a syscall (setns) that can be used to reassociate a thread with a namespace. The nsenter command line tool will help with that.\nWe can check the namespaces for a given process by querying the /proc filesystem:\nFrom a shell outside the chroot get the PID for the chrooted shell\nUNSHARE_PPID=$(ps -ef | grep \"sudo unshare\" | grep chroot | awk '{print $2}') UNSHARE_PID=$(ps -ef | grep ${UNSHARE_PPID} | grep chroot | grep -v sudo | awk '{print $2}') SHELL_PID=$(ps -ef | grep ${UNSHARE_PID} | grep -v chroot | grep /bin/sh | awk '{print $2}') ps -ef | grep ${UNSHARE_PID} | grep -v chroot | grep /bin/sh root 390072 390071 0 12:32 pts/1 00:00:00 /bin/sh From a shell outside the chroot get the namespaces for the shell process:\nsudo ls -l /proc/${SHELL_PID}/ns total 0 lrwxrwxrwx. 1 root root 0 mar 25 12:54 cgroup -\u003e 'cgroup:[4026531835]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 ipc -\u003e 'ipc:[4026531839]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 mnt -\u003e 'mnt:[4026532266]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 net -\u003e 'net:[4026532008]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 pid -\u003e 'pid:[4026532489]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 pid_for_children -\u003e 'pid:[4026532489]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 time -\u003e 'time:[4026531834]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 time_for_children -\u003e 'time:[4026531834]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 user -\u003e 'user:[4026531837]' lrwxrwxrwx. 1 root root 0 mar 25 12:54 uts -\u003e 'uts:[4026531838]' Earlier we saw how we were just setting a different PID namespace, let’s see the difference between the PID namespace configured for our chroot shell and for the regular shell:\nNOTE: Below commands must be run from a shell outside the chroot:\nGet PID namespace for the chrooted shell:\nsudo ls -l /proc/${SHELL_PID}/ns/pid lrwxrwxrwx. 1 root root 0 mar 25 12:54 pid -\u003e pid:[4026532489] Get PID namespace for the regular shell:\nsudo ls -l /proc/$$/ns/pid lrwxrwxrwx. 1 mario mario 0 mar 25 12:55 pid -\u003e pid:[4026531836] As you can see, both processes are using a different PID namespace. We saw that network stack was still visible, let’s see if there is any difference in the Network namespace for both processes. Let’s start with the chrooted shell:\nsudo ls -l /proc/${SHELL_PID}/ns/net lrwxrwxrwx. 1 root root 0 mar 25 12:54 net -\u003e net:[4026532008] Now, time to get the one for the regular shell:\nsudo ls -l /proc/$$/ns/net lrwxrwxrwx. 1 mario mario 0 mar 25 12:55 net -\u003e net:[4026532008] As you can see from above outputs, both processes are using the same Network namespace.\nIf we want to join a process to an existing namespace we can do that using nsenter as we said before, let’s do that.\nOpen a new shell outside the chroot\nWe want run a new chrooted shell and join the already existing PID namespace we created earlier:\n# Get the previous unshare PPID UNSHARE_PPID=$(ps -ef | grep \"sudo unshare\" | grep chroot | awk '{print $2}') # Get the previous unshare PID UNSHARE_PID=$(ps -ef | grep ${UNSHARE_PPID} | grep chroot | grep -v sudo | awk '{print $2}') # Get the previous chrooted shell PID SHELL_PID=$(ps -ef | grep ${UNSHARE_PID} | grep -v chroot | grep /bin/sh | awk '{print $2}') # We will enter the previous PID namespace, remount the /proc filesystem and run a new chrooted shell sudo nsenter --pid=/proc/${SHELL_PID}/ns/pid unshare -f --mount-proc=/tmp/alpine-rootfs/proc chroot /tmp/alpine-rootfs/ /bin/sh From the new chrooted shell we can run a ps command and we should see the existing processes from the previous chrooted shell:\nps -ef PID USER TIME COMMAND 1 root 0:00 /bin/sh 4 root 0:00 unshare -f --mount-proc=/tmp/alpine-rootfs/proc chroot /tmp/alpine-rootfs/ /bin/sh 5 root 0:00 /bin/sh 6 root 0:00 ps -ef We have entered the already existing PID namespace used by our previous chrooted shell and we can see that running a ps command from the new shell (PID 5) we can see the first shell (PID 1).\nInjecting files or directories into the chroot Containers are usually inmutables, that means that we cannot create or edit directories or files into the chroot. Sometimes we will need to inject files or directories either for storage or configuration. We are going to show how we can create some files on the host system and expose them as read-only to the chrooted shell using mount.\nCreate a folder in the host system to host some read-only config files:\nsudo mkdir -p /var/tmp/alpine-container-configs/ echo \"Test\" | sudo tee -a /var/tmp/alpine-container-configs/app-config echo \"Test2\" | sudo tee -a /var/tmp/alpine-container-configs/srv-config Create a folder in the rootfs directory to use it as mount point:\nsudo mkdir -p /var/tmp/alpine-rootfs/etc/myconfigs Run a bind mount:\nsudo mount --bind -o ro /var/tmp/alpine-container-configs /var/tmp/alpine-rootfs/etc/myconfigs Run a chrooted shell and check the mounted files:\nNOTE: You can exit from the already existing chrooted shells before creating this one\nsudo unshare -p -f --mount-proc=/var/tmp/alpine-rootfs/proc chroot /var/tmp/alpine-rootfs/ /bin/sh ls -l /etc/myconfigs/ total 8 -rw-r--r-- 1 root root 5 Mar 25 13:28 app-config -rw-r--r-- 1 root root 6 Mar 25 13:28 srv-config If we try to edit the files from the chrooted shell, this is what happens:\necho \"test3\" \u003e\u003e /etc/myconfigs/app-config NOTE: We cannot edit/create files since the mount is read-only\n/bin/sh: can't create /etc/myconfigs/app-config: Read-only file system If we want to unmount the files we can run the command below from the host system:\nsudo umount /var/tmp/alpine-rootfs/etc/myconfigs CGroups Control groups allow the kernel to restrict resources like memory and CPU for specific processes. In this case we are going to create a new CGroup for our chrooted shell so it cannot use more than 200MB of RAM.\nKernel exposes cgroups at the /sys/fs/cgroup directory:\nls /sys/fs/cgroup/ cgroup.controllers cgroup.stat cpuset.cpus.effective io.cost.model machine.slice system.slice cgroup.max.depth cgroup.subtree_control cpuset.mems.effective io.cost.qos memory.numa_stat user.slice cgroup.max.descendants cgroup.threads cpu.stat io.pressure memory.pressure cgroup.procs cpu.pressure init.scope io.stat memory.stat Let’s create a new cgroup, we just need to create a folder for that to happen:\nsudo mkdir /sys/fs/cgroup/alpinecgroup ls /sys/fs/cgroup/alpinecgroup/ NOTE: The kernel automatically populated the folder\ncgroup.controllers cgroup.stat io.pressure memory.max memory.swap.current pids.max cgroup.events cgroup.subtree_control memory.current memory.min memory.swap.events cgroup.freeze cgroup.threads memory.events memory.numa_stat memory.swap.high cgroup.max.depth cgroup.type memory.events.local memory.oom.group memory.swap.max cgroup.max.descendants cpu.pressure memory.high memory.pressure pids.current cgroup.procs cpu.stat memory.low memory.stat pids.events Now, we just need to adjust the memory value by modifying the required files:\n# Set a limit of 200MB of RAM echo \"200000000\" | sudo tee -a /sys/fs/cgroup/alpinecgroup/memory.max # Disable swap echo \"0\" | sudo tee -a /sys/fs/cgroup/alpinecgroup/memory.swap.max Finally, we need to assign this CGroup to our chrooted shell:\n# Get the previous unshare PPID UNSHARE_PPID=$(ps -ef | grep \"sudo unshare\" | grep chroot | awk '{print $2}') # Get the previous unshare PID UNSHARE_PID=$(ps -ef | grep ${UNSHARE_PPID} | grep chroot | grep -v sudo | awk '{print $2}') # Get the previous chrooted shell PID SHELL_PID=$(ps -ef | grep ${UNSHARE_PID} | grep -v chroot | grep /bin/sh | awk '{print $2}') # Assign the shell process to the cgroup echo ${SHELL_PID} | sudo tee -a /sys/fs/cgroup/alpinecgroup/cgroup.procs In order to test the cgroup we will create a dumb python script in the chrooted shell:\n# Mount the /dev fs since we need to read data from urandom mount -t devtmpfs dev /dev # Create the python script cat \u003c /opt/dumb.py f = open(\"/dev/urandom\", \"r\", encoding = \"ISO-8859-1\") data = \"\" i=0 while i \u003c 20: data += f.read(10000000) # 10mb i += 1 print(\"Used %d MB\" % (i * 10)) EOF Run the script:\npython3 /opt/dumb.py NOTE: The process was killed before it reached the memory limit.\npython3 /opt/dumb.py Used 10 MB Used 20 MB Used 30 MB Used 40 MB Used 50 MB Used 60 MB Used 70 MB Used 80 MB Used 90 MB Used 100 MB Used 110 MB Used 120 MB Used 130 MB Used 140 MB Used 150 MB Used 160 MB Used 170 MB Killed We can now close the chrooted shell and remove the cgroup\nExit the chrooted shell:\nexit NOTE: A CGroup cannot be removed until all the attached processes are finished.\nRemove the cgroup:\nsudo rmdir /sys/fs/cgroup/alpinecgroup/ Container security and capabilities As you know, Linux containers run directly on top of the host system and share multiple resources like the Kernel, filesystems, network stack, etc. If an attacker breaks out of the container confinement security risks will arise.\nIn order to limit the attack surface there are many technologies involved in limiting the power of processes running in the container such as SELinux, Security Compute Profiles and Linux Capabilities.\nYou can learn more in this blogpost.\nClosing Thoughts Containers are not new, they use technologies that have been present in the Linux kernel for a long time. Tools like Podman or Docker make running containers easy for everyone by abstracting the different Linux technologies used under the hood from the user.\nI hope that now you have a better understanding of what technologies are used when you run containers on your systems.\nSources Containers from from Scratch Creating CGroupsv2 ","wordCount":"2459","inLanguage":"en","datePublished":"2021-03-25T00:00:00Z","dateModified":"2021-03-25T00:00:00Z","author":{"@type":"Person","name":"Mario"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://linuxera.org/containers-under-the-hood/"},"publisher":{"@type":"Organization","name":"Linuxera","logo":{"@type":"ImageObject","url":"https://linuxera.org/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://linuxera.org/ accesskey=h title="Linuxera (Alt + H)">Linuxera</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://linuxera.org/ title="🏠 Home"><span>🏠 Home</span></a></li><li><a href=https://linuxera.org/archives/ title="🗄️ Archive"><span>🗄️ Archive</span></a></li><li><a href=https://linuxera.org/search/ title="🔎 Search"><span>🔎 Search</span></a></li><li><a href=https://linuxera.org/tags/ title="🏷️ Tags"><span>🏷️ Tags</span></a></li><li><a href=https://linuxera.org/presentations/ title="🎴 Presentations"><span>🎴 Presentations</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://linuxera.org/>Home</a>&nbsp;»&nbsp;<a href=https://linuxera.org/posts/>Posts</a></div><h1 class=post-title>Containers under the Hood</h1><div class=post-meta><span title='2021-03-25 00:00:00 +0000 UTC'>Published on March 25, 2021</span>&nbsp;·&nbsp;<span title='2021-03-25 00:00:00 +0000 UTC'>Last updated on March 25, 2021</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Mario</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#containers-are-linux aria-label="Containers are Linux">Containers are Linux</a><ul><li><a href=#container-file-systems-aka-rootfs aria-label="Container File Systems (a.k.a rootfs)">Container File Systems (a.k.a rootfs)</a><ul><li><a href=#chroot aria-label=chroot>chroot</a></li></ul></li><li><a href=#namespaces aria-label=namespaces>namespaces</a><ul><li><a href=#creating-namespaces-with-unshare aria-label="Creating namespaces with unshare">Creating namespaces with unshare</a></li><li><a href=#entering-namespaces-with-nsenter aria-label="Entering namespaces with nsenter">Entering namespaces with nsenter</a></li></ul></li><li><a href=#injecting-files-or-directories-into-the-chroot aria-label="Injecting files or directories into the chroot">Injecting files or directories into the chroot</a></li><li><a href=#cgroups aria-label=CGroups>CGroups</a></li><li><a href=#container-security-and-capabilities aria-label="Container security and capabilities">Container security and capabilities</a></li></ul></li><li><a href=#closing-thoughts aria-label="Closing Thoughts">Closing Thoughts</a></li><li><a href=#sources aria-label=Sources>Sources</a></li></ul></div></details></div><div class=post-content><h1 id=containers-are-linux>Containers are Linux<a hidden class=anchor aria-hidden=true href=#containers-are-linux>#</a></h1><p>You probably already heard this expression, in today&rsquo;s post we are going to desmitify container technologies by decomposing them part by part and describing which Linux technologies make containers possible.</p><p>We can describe a container as an isolated process running on a host. In order to isolate the process the container runtimes leverage Linux kernel technologies such as: namespaces, chroots, cgroups, etc. plus security layers like SELinux.</p><p>We will see how we can leverage these technologies on Linux in order to build and run our own containers.</p><h2 id=container-file-systems-aka-rootfs>Container File Systems (a.k.a rootfs)<a hidden class=anchor aria-hidden=true href=#container-file-systems-aka-rootfs>#</a></h2><p>Whenever you pull an image container from a container registry, you&rsquo;re downloading just a tarball. We can say container images are just tarballs.</p><p>There are multiple ways to get a rootfs that we can use in order to run our containers, for this blogpost we&rsquo;re going to download an already built rootfs for Alpine Linux.</p><p>There are tools such as <a href=https://buildroot.org/>buildroot</a> that make it really easy to create our own rootfs. We will see how to create our own rootfs using buildroot on a future post.</p><p>As earlier mentioned, let&rsquo;s download the x86_64 rootfs for <a href=https://alpinelinux.org/downloads/>Alpine Linux</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>mkdir /var/tmp/alpine-rootfs/ <span class=o>&amp;&amp;</span> <span class=nb>cd</span> <span class=nv>$_</span>
</span></span><span class=line><span class=cl>curl https://dl-cdn.alpinelinux.org/alpine/v3.12/releases/x86_64/alpine-minirootfs-3.12.3-x86_64.tar.gz -o rootfs.tar.gz
</span></span></code></pre></div><p>We can extract the rootfs on the temporary folder we just created:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>tar xfz rootfs.tar.gz <span class=o>&amp;&amp;</span> rm -f rootfs.tar.gz
</span></span></code></pre></div><p>If we take a look at the extracted files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>tree -L <span class=m>1</span>
</span></span></code></pre></div><p>As you can see, the result looks like a Linux system. We have some well known directories in the Linux Filesystem Hierarchy Standard such as: <code>bin</code>, <code>tmp</code>, <code>dev</code>, <code>opt</code>, etc.</p><pre tabindex=0><code>.
├── bin
├── dev
├── etc
├── home
├── lib
├── media
├── mnt
├── opt
├── proc
├── root
├── run
├── sbin
├── srv
├── sys
├── tmp
├── usr
└── var
</code></pre><h3 id=chroot>chroot<a hidden class=anchor aria-hidden=true href=#chroot>#</a></h3><p>Chroot is an operation that changes the root directory for the current running process and their children. A process that runs inside a chroot cannot access files and commands outside the chrooted directory tree.</p><p>That being said, we can now chroot into the rootfs environment we extracted in the previous step and run a shell to poke around:</p><ol><li><p>Create the chroot jail</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo chroot /var/tmp/alpine-rootfs/ /bin/sh
</span></span></code></pre></div></li><li><p>Check the os-release</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>cat /etc/os-release
</span></span></code></pre></div><pre tabindex=0><code>NAME=&#34;Alpine Linux&#34;
ID=alpine
VERSION_ID=3.12.3
PRETTY_NAME=&#34;Alpine Linux v3.12&#34;
HOME_URL=&#34;https://alpinelinux.org/&#34;
BUG_REPORT_URL=&#34;https://bugs.alpinelinux.org/&#34;
</code></pre></li><li><p>Try to list /tmp/alpine-rootfs folder</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ls /var/tmp/alpine-rootfs
</span></span></code></pre></div><pre tabindex=0><code>ls: /var/tmp/alpine-rootfs: No such file or directory
</code></pre></li></ol><p>As you can see we only have visibility of the contents of the rootfs we&rsquo;ve chroot into.</p><p>We can now install python and run a simple http server for example:</p><ol><li><p>Install python3</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>apk add python3
</span></span></code></pre></div></li><li><p>Run a simple http server</p><blockquote><p><strong>NOTE</strong>: When we execute the Python interpreter we&rsquo;re actually running it from <code>/var/tmp/alpine-rootfs/usr/bin/python3</code></p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>python3 -m http.server
</span></span></code></pre></div></li><li><p>If you open a new shell on your system (even if it&rsquo;s outside of the chroot) you will be able to reach the http server we just created:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>curl http://127.0.0.1:8000
</span></span></code></pre></div></li></ol><h2 id=namespaces>namespaces<a hidden class=anchor aria-hidden=true href=#namespaces>#</a></h2><p>At this point we were able to work with a tarball like if it was a different system, but we&rsquo;re not isolating the processed from the host system like containers do.</p><p>Let&rsquo;s check the level of isolation:</p><ol><li><p>In a shell outside the chroot run a <code>ping</code> command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ping 127.0.0.1
</span></span></code></pre></div></li><li><p>Mount the <code>proc</code> filesystem inside the chrooted shell</p><blockquote><p><strong>NOTE</strong>: If you&rsquo;re still running the python http server you can kill the process</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>mount -t proc proc /proc
</span></span></code></pre></div></li><li><p>Run a <code>ps</code> command inside the chroot and try to find the <code>ping</code> command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ps -ef <span class=p>|</span> grep <span class=s2>&#34;ping 127.0.0.1&#34;</span>
</span></span></code></pre></div><pre tabindex=0><code>387870 1000      0:00 ping 127.0.0.1
388204 root      0:00 grep ping 127.0.0.1
</code></pre></li><li><p>We have visibility over the host system processes, that&rsquo;s not great. On top of that, our chroot is running as root so we can even kill the process:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>pkill -f <span class=s2>&#34;ping 127.0.0.1&#34;</span>
</span></span></code></pre></div></li></ol><p>Now is when we introduce namespaces.</p><p><strong>Linux namespaces</strong> are a feature of the Linux kernel that partitions kernel resources so one process will only see a set of resources while a different process can see a different set of resources.</p><p>These resources may exist in multiple spaces. The list of existing namespaces are:</p><table><thead><tr><th>Namespace</th><th>Isolates</th></tr></thead><tbody><tr><td>Cgroup</td><td>Cgroup root directory</td></tr><tr><td>IPC</td><td>System V IPC, POSIX message queues</td></tr><tr><td>Network</td><td>Network devices, stacks, prots, etc.</td></tr><tr><td>Mount</td><td>Mount points</td></tr><tr><td>PID</td><td>Process IDs</td></tr><tr><td>Time</td><td>Boot and monotonic clocks</td></tr><tr><td>User</td><td>User and Group IDs</td></tr><tr><td>UTS</td><td>Hostname and NIS domain name</td></tr></tbody></table><br><h3 id=creating-namespaces-with-unshare>Creating namespaces with unshare<a hidden class=anchor aria-hidden=true href=#creating-namespaces-with-unshare>#</a></h3><p>Creating namespaces is just a single <a href=https://man7.org/linux/man-pages/man2/unshare.2.html>syscall (unshare)</a>. There is also a <code>unshare</code> command line tool that provides a nice wrapper around the syscall.</p><p>We are going to use the <code>unshare</code> command line to create namespaces manually. Below example will create a <code>PID</code> namespace for the chrooted shell:</p><ol><li><p>Exit the chroot we have already running</p><blockquote><p><strong>NOTE</strong>: Run below command on the chrooted shell</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div></li><li><p>Create the <code>PID</code> namespace and run the chrooted shell inside the namespace</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo unshare -p -f --mount-proc<span class=o>=</span>/var/tmp/alpine-rootfs/proc chroot /var/tmp/alpine-rootfs/ /bin/sh
</span></span></code></pre></div></li><li><p>Now that we have created our new process namespace, we will see that our shell thinks its PID is 1:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ps -ef
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: As you can see, we no longer see the host system processes</p></blockquote><pre tabindex=0><code>PID   USER     TIME  COMMAND
1 root      0:00 /bin/sh
2 root      0:00 ps -ef
</code></pre></li><li><p>Since we didn&rsquo;t create a namespace for the network we can still see the whole network stack from the host system:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ip -o a
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: Below output might vary on your system</p></blockquote><pre tabindex=0><code>1: lo    inet 127.0.0.1/8 scope host lo\       valid_lft forever preferred_lft forever
1: lo    inet6 ::1/128 scope host \       valid_lft forever preferred_lft forever
4: wlp82s0    inet 192.168.0.160/24 brd 192.168.0.255 scope global dynamic wlp82s0\       valid_lft 6555sec preferred_lft 6555sec
4: wlp82s0    inet6 fe80::4e03:6176:40f0:b862/64 scope link \       valid_lft forever preferred_lft forever
</code></pre></li></ol><h3 id=entering-namespaces-with-nsenter>Entering namespaces with nsenter<a hidden class=anchor aria-hidden=true href=#entering-namespaces-with-nsenter>#</a></h3><p>One powerful thing about namespaces is that they&rsquo;re pretty flexible, for example you can have processes with some separated namespaces and some shared namespaces. One example in the Kubernetes world will be containers running in pods: Containers will have different <code>PID</code> namespaces but they will share the <code>Network</code> namespace.</p><p>There is a <a href=https://man7.org/linux/man-pages/man2/setns.2.html>syscall (setns)</a> that can be used to reassociate a thread with a namespace. The <code>nsenter</code> command line tool will help with that.</p><p>We can check the namespaces for a given process by querying the <code>/proc</code> filesystem:</p><ol><li><p>From a shell outside the chroot get the PID for the chrooted shell</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nv>UNSHARE_PPID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=s2>&#34;sudo unshare&#34;</span> <span class=p>|</span> grep chroot <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>UNSHARE_PID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=si>${</span><span class=nv>UNSHARE_PPID</span><span class=si>}</span> <span class=p>|</span> grep chroot <span class=p>|</span> grep -v sudo <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>SHELL_PID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=si>${</span><span class=nv>UNSHARE_PID</span><span class=si>}</span> <span class=p>|</span> grep -v chroot <span class=p>|</span>  grep /bin/sh <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl>ps -ef <span class=p>|</span> grep <span class=si>${</span><span class=nv>UNSHARE_PID</span><span class=si>}</span> <span class=p>|</span> grep -v chroot <span class=p>|</span>  grep /bin/sh
</span></span></code></pre></div><pre tabindex=0><code>root      390072  390071  0 12:32 pts/1    00:00:00 /bin/sh
</code></pre></li><li><p>From a shell outside the chroot get the namespaces for the shell process:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo ls -l /proc/<span class=si>${</span><span class=nv>SHELL_PID</span><span class=si>}</span>/ns
</span></span></code></pre></div><pre tabindex=0><code>total 0
lrwxrwxrwx. 1 root root 0 mar 25 12:54 cgroup -&gt; &#39;cgroup:[4026531835]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 ipc -&gt; &#39;ipc:[4026531839]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 mnt -&gt; &#39;mnt:[4026532266]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 net -&gt; &#39;net:[4026532008]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 pid -&gt; &#39;pid:[4026532489]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 pid_for_children -&gt; &#39;pid:[4026532489]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 time -&gt; &#39;time:[4026531834]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 time_for_children -&gt; &#39;time:[4026531834]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 user -&gt; &#39;user:[4026531837]&#39;
lrwxrwxrwx. 1 root root 0 mar 25 12:54 uts -&gt; &#39;uts:[4026531838]&#39;
</code></pre></li><li><p>Earlier we saw how we were just setting a different <code>PID</code> namespace, let&rsquo;s see the difference between the <code>PID</code> namespace configured for our chroot shell and for the regular shell:</p><blockquote><p><strong>NOTE</strong>: Below commands must be run from a shell outside the chroot:</p></blockquote><ol><li><p>Get <code>PID</code> namespace for the chrooted shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo ls -l /proc/<span class=si>${</span><span class=nv>SHELL_PID</span><span class=si>}</span>/ns/pid
</span></span></code></pre></div><pre tabindex=0><code>lrwxrwxrwx. 1 root root 0 mar 25 12:54 pid -&gt; pid:[4026532489]
</code></pre></li><li><p>Get <code>PID</code> namespace for the regular shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo ls -l /proc/<span class=nv>$$</span>/ns/pid
</span></span></code></pre></div><pre tabindex=0><code>lrwxrwxrwx. 1 mario mario 0 mar 25 12:55 pid -&gt; pid:[4026531836]
</code></pre></li><li><p>As you can see, both processes are using a different <code>PID</code> namespace. We saw that network stack was still visible, let&rsquo;s see if there is any difference in the <code>Network</code> namespace for both processes. Let&rsquo;s start with the chrooted shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo ls -l /proc/<span class=si>${</span><span class=nv>SHELL_PID</span><span class=si>}</span>/ns/net
</span></span></code></pre></div><pre tabindex=0><code>lrwxrwxrwx. 1 root root 0 mar 25 12:54 net -&gt; net:[4026532008]
</code></pre></li><li><p>Now, time to get the one for the regular shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo ls -l /proc/<span class=nv>$$</span>/ns/net
</span></span></code></pre></div><pre tabindex=0><code>lrwxrwxrwx. 1 mario mario 0 mar 25 12:55 net -&gt; net:[4026532008]
</code></pre></li><li><p>As you can see from above outputs, both processes are using the same <code>Network</code> namespace.</p></li></ol></li></ol><p>If we want to join a process to an existing namespace we can do that using <code>nsenter</code> as we said before, let&rsquo;s do that.</p><ol><li><p>Open a new shell outside the chroot</p></li><li><p>We want run a new chrooted shell and join the already existing <code>PID</code> namespace we created earlier:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Get the previous unshare PPID</span>
</span></span><span class=line><span class=cl><span class=nv>UNSHARE_PPID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=s2>&#34;sudo unshare&#34;</span> <span class=p>|</span> grep chroot <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c1># Get the previous unshare PID</span>
</span></span><span class=line><span class=cl><span class=nv>UNSHARE_PID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=si>${</span><span class=nv>UNSHARE_PPID</span><span class=si>}</span> <span class=p>|</span> grep chroot <span class=p>|</span> grep -v sudo <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c1># Get the previous chrooted shell PID</span>
</span></span><span class=line><span class=cl><span class=nv>SHELL_PID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=si>${</span><span class=nv>UNSHARE_PID</span><span class=si>}</span> <span class=p>|</span> grep -v chroot <span class=p>|</span>  grep /bin/sh <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c1># We will enter the previous PID namespace, remount the /proc filesystem and run a new chrooted shell</span>
</span></span><span class=line><span class=cl>sudo nsenter --pid<span class=o>=</span>/proc/<span class=si>${</span><span class=nv>SHELL_PID</span><span class=si>}</span>/ns/pid unshare -f --mount-proc<span class=o>=</span>/tmp/alpine-rootfs/proc chroot /tmp/alpine-rootfs/ /bin/sh
</span></span></code></pre></div></li><li><p>From the new chrooted shell we can run a <code>ps</code> command and we should see the existing processes from the previous chrooted shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ps -ef
</span></span></code></pre></div><pre tabindex=0><code>PID   USER     TIME  COMMAND
  1   root     0:00  /bin/sh
  4   root     0:00  unshare -f --mount-proc=/tmp/alpine-rootfs/proc chroot /tmp/alpine-rootfs/ /bin/sh
  5   root     0:00  /bin/sh
  6   root    0:00  ps -ef
</code></pre></li><li><p>We have entered the already existing <code>PID</code> namespace used by our previous chrooted shell and we can see that running a <code>ps</code> command from the new shell (PID 5) we can see the first shell (PID 1).</p></li></ol><h2 id=injecting-files-or-directories-into-the-chroot>Injecting files or directories into the chroot<a hidden class=anchor aria-hidden=true href=#injecting-files-or-directories-into-the-chroot>#</a></h2><p>Containers are usually inmutables, that means that we cannot create or edit directories or files into the chroot. Sometimes we will need to inject files or directories either for storage or configuration. We are going to show how we can create some files on the host system and expose them as read-only to the chrooted shell using <code>mount</code>.</p><ol><li><p>Create a folder in the host system to host some read-only config files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo mkdir -p /var/tmp/alpine-container-configs/
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Test&#34;</span> <span class=p>|</span> sudo tee -a /var/tmp/alpine-container-configs/app-config
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;Test2&#34;</span> <span class=p>|</span> sudo tee -a /var/tmp/alpine-container-configs/srv-config
</span></span></code></pre></div></li><li><p>Create a folder in the rootfs directory to use it as mount point:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo mkdir -p /var/tmp/alpine-rootfs/etc/myconfigs
</span></span></code></pre></div></li><li><p>Run a bind mount:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo mount --bind -o ro /var/tmp/alpine-container-configs /var/tmp/alpine-rootfs/etc/myconfigs
</span></span></code></pre></div></li><li><p>Run a chrooted shell and check the mounted files:</p><blockquote><p><strong>NOTE</strong>: You can exit from the already existing chrooted shells before creating this one</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo unshare -p -f --mount-proc<span class=o>=</span>/var/tmp/alpine-rootfs/proc chroot /var/tmp/alpine-rootfs/ /bin/sh
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ls -l /etc/myconfigs/
</span></span></code></pre></div><pre tabindex=0><code>total 8
-rw-r--r--    1 root     root             5 Mar 25 13:28 app-config
-rw-r--r--    1 root     root             6 Mar 25 13:28 srv-config
</code></pre></li><li><p>If we try to edit the files from the chrooted shell, this is what happens:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;test3&#34;</span> &gt;&gt; /etc/myconfigs/app-config
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: We cannot edit/create files since the mount is read-only</p></blockquote><pre tabindex=0><code>/bin/sh: can&#39;t create /etc/myconfigs/app-config: Read-only file system
</code></pre></li><li><p>If we want to unmount the files we can run the command below from the host system:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo umount /var/tmp/alpine-rootfs/etc/myconfigs
</span></span></code></pre></div></li></ol><h2 id=cgroups>CGroups<a hidden class=anchor aria-hidden=true href=#cgroups>#</a></h2><p>Control groups allow the kernel to restrict resources like memory and CPU for specific processes. In this case we are going to create a new CGroup for our chrooted shell so it cannot use more than 200MB of RAM.</p><p>Kernel exposes <code>cgroups</code> at the <code>/sys/fs/cgroup</code> directory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>ls /sys/fs/cgroup/
</span></span></code></pre></div><pre tabindex=0><code>cgroup.controllers      cgroup.stat             cpuset.cpus.effective  io.cost.model  machine.slice     system.slice
cgroup.max.depth        cgroup.subtree_control  cpuset.mems.effective  io.cost.qos    memory.numa_stat  user.slice
cgroup.max.descendants  cgroup.threads          cpu.stat               io.pressure    memory.pressure
cgroup.procs            cpu.pressure            init.scope             io.stat        memory.stat
</code></pre><ol><li><p>Let&rsquo;s create a new cgroup, we just need to create a folder for that to happen:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo mkdir /sys/fs/cgroup/alpinecgroup
</span></span></code></pre></div><pre tabindex=0><code>ls /sys/fs/cgroup/alpinecgroup/
</code></pre><blockquote><p><strong>NOTE</strong>: The kernel automatically populated the folder</p></blockquote><pre tabindex=0><code>cgroup.controllers      cgroup.stat             io.pressure          memory.max        memory.swap.current  pids.max
cgroup.events           cgroup.subtree_control  memory.current       memory.min        memory.swap.events
cgroup.freeze           cgroup.threads          memory.events        memory.numa_stat  memory.swap.high
cgroup.max.depth        cgroup.type             memory.events.local  memory.oom.group  memory.swap.max
cgroup.max.descendants  cpu.pressure            memory.high          memory.pressure   pids.current
cgroup.procs            cpu.stat                memory.low           memory.stat       pids.events
</code></pre></li><li><p>Now, we just need to adjust the memory value by modifying the required files:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Set a limit of 200MB of RAM</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;200000000&#34;</span> <span class=p>|</span> sudo tee -a /sys/fs/cgroup/alpinecgroup/memory.max
</span></span><span class=line><span class=cl><span class=c1># Disable swap</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;0&#34;</span> <span class=p>|</span> sudo tee -a /sys/fs/cgroup/alpinecgroup/memory.swap.max
</span></span></code></pre></div></li><li><p>Finally, we need to assign this CGroup to our chrooted shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Get the previous unshare PPID</span>
</span></span><span class=line><span class=cl><span class=nv>UNSHARE_PPID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=s2>&#34;sudo unshare&#34;</span> <span class=p>|</span> grep chroot <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c1># Get the previous unshare PID</span>
</span></span><span class=line><span class=cl><span class=nv>UNSHARE_PID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=si>${</span><span class=nv>UNSHARE_PPID</span><span class=si>}</span> <span class=p>|</span> grep chroot <span class=p>|</span> grep -v sudo <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c1># Get the previous chrooted shell PID</span>
</span></span><span class=line><span class=cl><span class=nv>SHELL_PID</span><span class=o>=</span><span class=k>$(</span>ps -ef <span class=p>|</span> grep <span class=si>${</span><span class=nv>UNSHARE_PID</span><span class=si>}</span> <span class=p>|</span> grep -v chroot <span class=p>|</span>  grep /bin/sh <span class=p>|</span> awk <span class=s1>&#39;{print $2}&#39;</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=c1># Assign the shell process to the cgroup</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>SHELL_PID</span><span class=si>}</span> <span class=p>|</span> sudo tee -a /sys/fs/cgroup/alpinecgroup/cgroup.procs
</span></span></code></pre></div></li><li><p>In order to test the cgroup we will create a dumb python script in the chrooted shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># Mount the /dev fs since we need to read data from urandom</span>
</span></span><span class=line><span class=cl>mount -t devtmpfs dev /dev
</span></span><span class=line><span class=cl><span class=c1># Create the python script</span>
</span></span><span class=line><span class=cl>cat <span class=s>&lt;&lt;EOF &gt; /opt/dumb.py
</span></span></span><span class=line><span class=cl><span class=s>f = open(&#34;/dev/urandom&#34;, &#34;r&#34;, encoding = &#34;ISO-8859-1&#34;)
</span></span></span><span class=line><span class=cl><span class=s>data = &#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s>i=0
</span></span></span><span class=line><span class=cl><span class=s>while i &lt; 20:
</span></span></span><span class=line><span class=cl><span class=s>    data += f.read(10000000) # 10mb
</span></span></span><span class=line><span class=cl><span class=s>    i += 1
</span></span></span><span class=line><span class=cl><span class=s>    print(&#34;Used %d MB&#34; % (i * 10))
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span></code></pre></div></li><li><p>Run the script:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>python3 /opt/dumb.py
</span></span></code></pre></div><blockquote><p><strong>NOTE</strong>: The process was killed before it reached the memory limit.</p></blockquote><pre tabindex=0><code>python3 /opt/dumb.py
Used 10 MB
Used 20 MB
Used 30 MB
Used 40 MB
Used 50 MB
Used 60 MB
Used 70 MB
Used 80 MB
Used 90 MB
Used 100 MB
Used 110 MB
Used 120 MB
Used 130 MB
Used 140 MB
Used 150 MB
Used 160 MB
Used 170 MB
Killed
</code></pre></li><li><p>We can now close the chrooted shell and remove the cgroup</p><ol><li><p>Exit the chrooted shell:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=nb>exit</span>
</span></span></code></pre></div></li></ol><blockquote><p><strong>NOTE</strong>: A CGroup cannot be removed until all the attached processes are finished.</p></blockquote><ol start=2><li><p>Remove the cgroup:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>sudo rmdir /sys/fs/cgroup/alpinecgroup/
</span></span></code></pre></div></li></ol></li></ol><h2 id=container-security-and-capabilities>Container security and capabilities<a hidden class=anchor aria-hidden=true href=#container-security-and-capabilities>#</a></h2><p>As you know, Linux containers run directly on top of the host system and share multiple resources like the Kernel, filesystems, network stack, etc. If an attacker breaks out of the container confinement security risks will arise.</p><p>In order to limit the attack surface there are many technologies involved in limiting the power of processes running in the container such as SELinux, Security Compute Profiles and Linux Capabilities.</p><p>You can learn more in <a href=https://linuxera.org/container-security-capabilities-seccomp/>this blogpost</a>.</p><h1 id=closing-thoughts>Closing Thoughts<a hidden class=anchor aria-hidden=true href=#closing-thoughts>#</a></h1><p>Containers are not new, they use technologies that have been present in the Linux kernel for a long time. Tools like <a href=https://podman.io/>Podman</a> or <a href=https://www.docker.com/>Docker</a> make running containers easy for everyone by abstracting the different Linux technologies used under the hood from the user.</p><p>I hope that now you have a better understanding of what technologies are used when you run containers on your systems.</p><h1 id=sources>Sources<a hidden class=anchor aria-hidden=true href=#sources>#</a></h1><ul><li><a href=https://ericchiang.github.io/post/containers-from-scratch/>Containers from from Scratch</a></li><li><a href=https://facebookmicrosites.github.io/cgroup2/docs/create-cgroups.html>Creating CGroupsv2</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://linuxera.org/tags/containers/>containers</a></li><li><a href=https://linuxera.org/tags/linux/>linux</a></li><li><a href=https://linuxera.org/tags/namespaces/>namespaces</a></li><li><a href=https://linuxera.org/tags/nsenter/>nsenter</a></li><li><a href=https://linuxera.org/tags/unshare/>unshare</a></li><li><a href=https://linuxera.org/tags/kernel/>kernel</a></li><li><a href=https://linuxera.org/tags/selinux/>selinux</a></li></ul><nav class=paginav><a class=prev href=https://linuxera.org/container-security-capabilities-seccomp/><span class=title>« Prev</span><br><span>Container Security - Linux Capabilities and Secure Compute Profiles</span></a>
<a class=next href=https://linuxera.org/integrating-operators-olm/><span class=title>Next »</span><br><span>Integrating our Operators with OLM</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Containers under the Hood on twitter" href="https://twitter.com/intent/tweet/?text=Containers%20under%20the%20Hood&url=https%3a%2f%2flinuxera.org%2fcontainers-under-the-hood%2f&hashtags=containers%2clinux%2cnamespaces%2cnsenter%2cunshare%2ckernel%2cselinux"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Containers under the Hood on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2flinuxera.org%2fcontainers-under-the-hood%2f&title=Containers%20under%20the%20Hood&summary=Containers%20under%20the%20Hood&source=https%3a%2f%2flinuxera.org%2fcontainers-under-the-hood%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></div></footer><div class=share-buttons><p>If this post has been helpful to you, consider <u><a target=_blank href=https://ko-fi.com/mvazce>supporting the work.</a></u></p></div><script src=https://utteranc.es/client.js repo=mvazquezc/mvazquezc.github.io issue-term=pathname label=blog-comments theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://linuxera.org/>Linuxera</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>